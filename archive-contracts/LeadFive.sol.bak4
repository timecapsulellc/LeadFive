// SPDX-License-Identifier: MIT
pragma solidity 0.8.22;

// Optimized libraries for gas efficiency and modularity
import "./libraries/Errors.sol";
import "./libraries/CoreOptimized.sol";

// OpenZeppelin upgradeable contracts
import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
import "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/utils/PausableUpgradeable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol";

/**
 * @title LEAD FIVE: THE DECENTRALIZED INCENTIVE PLATFORM
 * @notice Smart Rewards, Powered by Blockchain
 * @dev Lead Five is a next-generation incentive protocol built on Binance Smart Chain, 
 *      combining autonomous smart contracts with decentralized governance. Unlike traditional 
 *      models, our technology platform enforces fairness through algorithmic distribution, 
 *      multi-audited security, and a sustainable 4x earnings capâ€”all verifiable on-chain.
 *      Version: 1.1.0 - Upgraded with USDT Management
 * @author LeadFive Development Team
 */
contract LeadFive is 
    Initializable, 
    UUPSUpgradeable, 
    OwnableUpgradeable, 
    ReentrancyGuardUpgradeable, 
    PausableUpgradeable 
{
    using CoreOptimized for *;

    // ========== STATE VARIABLES ==========
    
    // Core user and package management
    mapping(address => CoreOptimized.PackedUser) public users;
    mapping(uint8 => CoreOptimized.PackedPackage) public packages;
    mapping(address => address[]) public directNetwork;
    mapping(address => address[2]) public smartTreeMatrix;
    mapping(uint32 => address) public userIds;
    
    // Pool management - Algorithmic reward distribution
    CoreOptimized.PackedPool public leadershipPool;
    CoreOptimized.PackedPool public communityPool;
    CoreOptimized.PackedPool public clubPool;
    CoreOptimized.PackedPool public algorithmicPool;
    
    // Network optimization mappings
    mapping(address => uint256) public leftLegVolume;
    mapping(address => uint256) public rightLegVolume;
    mapping(address => uint32) public networkSizeCache;
    mapping(address => uint256) public lastNetworkUpdate;
    
    // Security and rate limiting
    mapping(address => bool) public isAdminAddress;
    mapping(address => uint256) public dailyWithdrawals;
    mapping(address => uint256) public lastWithdrawalDay;
    mapping(address => uint256) public userLastTx;
    
    // Circuit breaker system
    uint256 public circuitBreakerThreshold;
    bool public circuitBreakerTriggered;
    uint256 public lastTxBlock;
    
    // Global statistics
    uint32 public totalUsers;
    uint96 public totalPlatformFeesCollected;
    uint256 public dailyWithdrawalLimit;
    IERC20 public usdt;
    address public platformFeeRecipient;
    
    // Production variables
    uint8 public usdtDecimals;
    
    // Upgradeable proxy storage gap for future variables
    uint256[49] private __gap;

    // ========== EVENTS ==========
    
    // Core business events
    event UserRegistered(address indexed user, address indexed sponsor, uint8 packageLevel, uint96 amount);
    event PackageUpgraded(address indexed user, uint8 newLevel, uint96 amount);
    event RewardDistributed(address indexed recipient, uint96 amount, uint8 rewardType);
    event UserWithdrawal(address indexed user, uint96 amount);
    event PoolDistributed(uint8 poolType, uint96 amount);
    event PlatformFeeCollected(uint96 amount, address indexed user);
    
    // Security and admin events
    event AdminAdded(address indexed admin);
    event AdminRemoved(address indexed admin);
    event CircuitBreakerTriggered(uint256 amount, uint256 threshold);
    event CircuitBreakerReset();
    event EarningsCapReached(address indexed user, uint96 exceededAmount);
    
    // Algorithmic system events
    event NetworkPositionAssigned(address indexed user, uint32 position);
    event AlgorithmicBonusDistributed(address indexed user, uint96 amount);
    event MatrixCycleCompleted(address indexed user, uint256 cycle);
    
    // Production launch events
    event ProductionInitialized(uint8 usdtDecimals);
    event USDTPaymentProcessed(address indexed user, uint256 amount18, uint96 amount6);
    event USDTAddressUpdated(address indexed oldAddress, address indexed newAddress);
    
    // ========== MODIFIERS ==========
    
    modifier onlyAdmin() {
        require(isAdminAddress[msg.sender] || msg.sender == owner(), "Not authorized");
        _;
    }
    
    modifier antiMEV() {
        require(lastTxBlock != block.number && userLastTx[msg.sender] != block.number, "MEV protection");
        lastTxBlock = block.number;
        userLastTx[msg.sender] = block.number;
        _;
    }
    
    modifier circuitBreakerCheck(uint256 amount) {
        if (amount > circuitBreakerThreshold && circuitBreakerThreshold > 0) {
            circuitBreakerTriggered = true;
            emit CircuitBreakerTriggered(amount, circuitBreakerThreshold);
            revert Errors.CircuitBreakerActivated();
        }
        _;
    }
    
    modifier dailyLimitCheck(uint256 amount) {
        uint256 currentDay = block.timestamp / 86400;
        
        if (lastWithdrawalDay[msg.sender] != currentDay) {
            dailyWithdrawals[msg.sender] = 0;
            lastWithdrawalDay[msg.sender] = currentDay;
        }
        
        require(dailyWithdrawals[msg.sender] + amount <= dailyWithdrawalLimit, "Daily limit exceeded");
        dailyWithdrawals[msg.sender] += amount;
        _;
    }

    // ========== USDT MANAGEMENT FUNCTIONS ==========
    
    /**
     * @notice Set the USDT contract address
     * @dev This function allows the owner to set or update the USDT token address
     * @param _usdt The address of the USDT token contract
     */
    function setUSDTAddress(address _usdt) external onlyOwner {
        require(_usdt != address(0), "Invalid USDT address");
        
        address oldUsdt = address(usdt);
        usdt = IERC20(_usdt);
        
        // Get decimals from the token contract itself
        try IERC20Metadata(_usdt).decimals() returns (uint8 decimals) {
            // Use token's actual decimals but keep internal accounting at 6 decimals
            usdtDecimals = 6;
        } catch {
            // Default to 6 decimals if the call fails (token doesn't implement decimals)
            usdtDecimals = 6;
        }
        
        emit USDTAddressUpdated(oldUsdt, _usdt);
    }
    
    /**
     * @notice Emergency function to set the USDT contract address
     * @dev This function allows the owner to set the USDT address even when the contract is paused
     * @param _usdt The address of the USDT token contract
     */
    function emergencySetUSDT(address _usdt) external onlyOwner {
        require(_usdt != address(0), "Invalid USDT address");
        
        address oldUsdt = address(usdt);
        usdt = IERC20(_usdt);
        usdtDecimals = 6; // Force 6 decimals for emergency recovery
        
        emit USDTAddressUpdated(oldUsdt, _usdt);
    }
    
    /**
     * @notice Check if USDT is properly configured
     * @dev Returns true if USDT address is set and has non-zero balance
     * @return isConfigured Boolean indicating if USDT is properly configured
     */
    function isUSDTConfigured() external view returns (bool) {
        return address(usdt) != address(0) && usdtDecimals > 0;
    }
    
    /**
     * @notice Get USDT configuration details
     * @dev Returns USDT address, decimals, and contract balance
     * @return usdtAddress The address of the USDT token
     * @return decimals The number of decimals used for USDT
     * @return balance The USDT balance of the contract
     */
    function getUSDTConfig() external view returns (
        address usdtAddress,
        uint8 decimals,
        uint256 balance
    ) {
        usdtAddress = address(usdt);
        decimals = usdtDecimals;
        balance = usdtAddress != address(0) ? usdt.balanceOf(address(this)) : 0;
    }

    // ========== PRODUCTION INITIALIZATION ==========
    
    /**
     * @dev Initialize production features for existing deployment
     * This function should be called immediately after deployment
     */
    function initializeProduction() external onlyOwner {
        require(usdtDecimals == 0, "Production already initialized");
        
        // Set USDT decimals to 6 (as originally designed)
        // This fixes the decimal mismatch issue with BSC USDT (18 decimals)
        usdtDecimals = 6;
        
        // Update package prices
        _setStandardPackagePrices();
        
        // Set initial withdrawal limit
        dailyWithdrawalLimit = uint96(1000 * 10**6); // 1000 USDT with 6 decimals
        
        emit ProductionInitialized(usdtDecimals);
    }
    
    /**
     * @dev Sets the standard package prices with proper decimal handling
     */
    function _setStandardPackagePrices() private {
        // Set package prices with 6 decimals for USDT
        packages[1].price = uint96(30 * 10**6);   // 30 USDT = 30,000,000 units (6 decimals)
        packages[2].price = uint96(50 * 10**6);   // 50 USDT = 50,000,000 units (6 decimals)
        packages[3].price = uint96(100 * 10**6);  // 100 USDT = 100,000,000 units (6 decimals)
        packages[4].price = uint96(200 * 10**6);  // 200 USDT = 200,000,000 units (6 decimals)
    }
    
    // ========== CORE CONTRACT FUNCTIONS ==========
    
    /**
     * @dev Initialize the contract with USDT address
     * @param _usdt The address of the USDT token contract
     */
    function initialize(address _usdt) external initializer {
        __Ownable_init(msg.sender);
        __UUPSUpgradeable_init();
        __ReentrancyGuard_init();
        __Pausable_init();
        
        // Initialize USDT token
        if (_usdt == address(0)) {
            revert Errors.ZeroAddress();
        }
        usdt = IERC20(_usdt);
        
        // Set USDT decimals to 6 (as originally designed for new deployments)
        usdtDecimals = 6;
        
        // Initialize packages with proper decimal handling
        _initializePackages();
        
        // Set initial limits and thresholds
        dailyWithdrawalLimit = uint96(1000 * 10**6); // 1000 USDT with 6 decimals
        circuitBreakerThreshold = uint96(10000 * 10**6); // 10,000 USDT with 6 decimals

        CoreOptimized.PackedUser storage platformUser = users[msg.sender];
        platformUser.setRegistered(true);
        platformUser.packageLevel = 4;
        platformUser.rank = 5;
        platformUser.earningsCap = type(uint96).max;
        platformUser.registrationTime = uint32(block.timestamp);
        platformUser.withdrawalRate = 90;
        userIds[1] = msg.sender;
        totalUsers = 1;

        emit AdminAdded(msg.sender);
    }
    
    function _initializePackages() private {
        // Package prices using 6 decimals (as originally designed)
        // This fixes the mismatch with BSC USDT's 18 decimals
        
        // Package Level 1: $30 USDT = 30,000,000 units (6 decimals)
        packages[1] = CoreOptimized.PackedPackage({
            price: uint96(30 * 10**6), // 30 USDT with 6 decimals
            directBonus: 4000, // 40%
            levelBonus: 1000, // 10%
            uplineBonus: 1000, // 10% - Upline chain bonuses
            leaderBonus: 1000, // 10%
            helpBonus: 1000, // 10%
            clubBonus: 1000 // 10%
        });
        
        // Package Level 2: $50 USDT = 50,000,000 units (6 decimals)
        packages[2] = CoreOptimized.PackedPackage({
            price: uint96(50 * 10**6), // 50 USDT with 6 decimals
            directBonus: 4000, // 40%
            levelBonus: 1000, // 10%
            uplineBonus: 1000, // 10% - Upline chain bonuses
            leaderBonus: 1000, // 10%
            helpBonus: 1000, // 10%
            clubBonus: 1500 // 15%
        });
        
        // Package Level 3: $100 USDT = 100,000,000 units (6 decimals)
        packages[3] = CoreOptimized.PackedPackage({
            price: uint96(100 * 10**6), // 100 USDT with 6 decimals
            directBonus: 4000, // 40%
            levelBonus: 1000, // 10%
            uplineBonus: 1000, // 10% - Upline chain bonuses
            leaderBonus: 1000, // 10%
            helpBonus: 1000, // 10%
            clubBonus: 2000 // 20%
        });
        
        // Package Level 4: $200 USDT = 200,000,000 units (6 decimals)
        packages[4] = CoreOptimized.PackedPackage({
            price: uint96(200 * 10**6), // 200 USDT with 6 decimals
            directBonus: 4000, // 40%
            levelBonus: 1000, // 10%
            uplineBonus: 1000, // 10% - Upline chain bonuses
            leaderBonus: 1000, // 10%
            helpBonus: 1000, // 10%
            clubBonus: 2500 // 25%
        });
    }

    // ========== REGISTRATION FUNCTIONS ==========
    
    function register(
        address sponsor,
        uint8 packageLevel
    ) external nonReentrant whenNotPaused antiMEV circuitBreakerCheck(packages[packageLevel].price) {
        require(!users[msg.sender].isRegistered(), "Already registered");
        require(users[sponsor].isRegistered() || sponsor == address(0), "Invalid sponsor");
        require(packageLevel > 0 && packageLevel <= 4, "Invalid package");
        
        // Process USDT payment only
        uint96 packagePrice = _processUSDTPayment(packageLevel);
        
        // Register user with packed data structure
        _registerUserInternal(sponsor, packageLevel, packagePrice);
        
        // Process payments and rewards
        _processRegistrationPayments(sponsor, packageLevel, packagePrice);
        
        // Update network structures
        _updateNetworkStructure(msg.sender, sponsor);
        
        emit UserRegistered(msg.sender, sponsor, packageLevel, packagePrice);
    }

    function upgradePackage(uint8 newLevel) 
        external nonReentrant whenNotPaused antiMEV {
        CoreOptimized.PackedUser storage user = users[msg.sender];
        if (!user.isRegistered()) revert Errors.UserNotRegistered(msg.sender);
        if (user.isBlacklisted()) revert Errors.UserBlacklisted(msg.sender);
        if (newLevel <= user.packageLevel || newLevel > 4) revert Errors.InvalidPackageLevel(newLevel);
        
        uint96 amount = _processUSDTPayment(newLevel);
        
        user.packageLevel = newLevel;
        user.totalInvestment += amount;
        user.earningsCap += uint96(uint256(amount) * 4); // 4x earnings cap
        _processRegistrationPayments(user.referrer, newLevel, amount);
        emit PackageUpgraded(msg.sender, newLevel, amount);
    }

    function _processUSDTPayment(uint8 packageLevel) internal returns (uint96) {
        require(packageLevel > 0 && packageLevel <= 4, "Invalid package level");
        uint96 packagePrice = packages[packageLevel].price; // This is in 6 decimals
        require(packagePrice > 0, "Package price not set");
        
        // Convert 6-decimal package price to 18-decimal BSC USDT amount
        uint256 usdtAmount = uint256(packagePrice) * 10**12; // Convert from 6 to 18 decimals
        
        // Check user's USDT balance before transfer
        require(usdt.balanceOf(msg.sender) >= usdtAmount, "Insufficient USDT balance");
        require(usdt.allowance(msg.sender, address(this)) >= usdtAmount, "Insufficient USDT allowance");
        
        require(usdt.transferFrom(msg.sender, address(this), usdtAmount), "USDT transfer failed");
        
        // Emit payment processing event for transparency
        emit USDTPaymentProcessed(msg.sender, usdtAmount, packagePrice);
        
        return packagePrice; // Return the 6-decimal amount for internal accounting
    }
    
    function _registerUserInternal(
        address sponsor,
        uint8 packageLevel,
        uint96 packagePrice
    ) private {
        uint32 newUserId = ++totalUsers;
        
        CoreOptimized.PackedUser storage newUser = users[msg.sender];
        newUser.setRegistered(true);
        newUser.packageLevel = packageLevel;
        newUser.referrer = sponsor;
        newUser.balance = 0;
        newUser.totalEarnings = 0;
        newUser.totalInvestment = packagePrice;
        newUser.earningsCap = packagePrice * 4; // 4x earnings cap
        newUser.directReferrals = 0;
        newUser.teamSize = 0;
        newUser.registrationTime = uint32(block.timestamp);
        newUser.withdrawalRate = 40; // Default withdrawal rate

        userIds[newUserId] = msg.sender;
        
        if (sponsor != address(0)) {
            directNetwork[sponsor].push(msg.sender);
            users[sponsor].directReferrals++;
        }
    }
    
    // ========== REWARD DISTRIBUTION ==========
    
    function _processRegistrationPayments(
        address sponsor,
        uint8 packageLevel,
        uint96 packagePrice
    ) private {
        // No platform fee on registration, only on withdrawal
        
        // Calculate direct bonus (40% to sponsor)
        if (sponsor != address(0)) {
            uint96 directBonus = (packagePrice * packages[packageLevel].directBonus) / 10000;
            _distributeReward(sponsor, directBonus, 1); // Type 1 = Direct bonus

            // Referrer chain distribution - 10% to 30 participants
            uint96 chainAmount = (packagePrice * 1000) / 10000;
            _distributeReferrerChainIncentives(msg.sender, chainAmount);
        }
        
        // Distribute level bonuses (10% across 10 levels)
        _distributeLevelBonuses(sponsor, packagePrice, packageLevel);
        
        // Allocate to pools (remaining amount after fees and bonuses)
        _allocateToPoolsOptimized(packagePrice, packageLevel);
    }
    
    function _distributeLevelBonuses(
        address startSponsor,
        uint96 packagePrice,
        uint8 packageLevel
    ) private {
        address currentSponsor = startSponsor;
        uint96 levelBonus = (packagePrice * packages[packageLevel].levelBonus) / 10000;
        
        // Iterative implementation
        for (uint8 level = 1; level <= 10 && currentSponsor != address(0); level++) {
            if (users[currentSponsor].packageLevel >= packageLevel) {
                _distributeReward(currentSponsor, levelBonus, 2); // Type 2 = Level bonus
            }
            currentSponsor = users[currentSponsor].referrer;
        }
    }
    
    function _distributeReward(address recipient, uint96 amount, uint8 rewardType) private {
        if (recipient == address(0) || amount == 0) return;
        
        CoreOptimized.PackedUser storage user = users[recipient];
        
        // Check earnings cap
        if (user.totalEarnings + amount > user.earningsCap) {
            uint96 exceededAmount = (user.totalEarnings + amount) - user.earningsCap;
            amount = user.earningsCap - user.totalEarnings;
            emit EarningsCapReached(recipient, exceededAmount);
        }
        
        if (amount > 0) {
            user.balance += amount;
            user.totalEarnings += amount;
            emit RewardDistributed(recipient, amount, rewardType);
        }
    }

    // ========== POOL MANAGEMENT ==========
    
    function _allocateToPoolsOptimized(uint96 packagePrice, uint8 packageLevel) private {
        CoreOptimized.PackedPackage storage packageData = packages[packageLevel];
        
        // Calculate pool allocations based on package bonuses
        uint96 leadershipShare = (packagePrice * packageData.leaderBonus) / 10000;
        uint96 communityShare = (packagePrice * packageData.helpBonus) / 10000;  
        uint96 clubShare = (packagePrice * packageData.clubBonus) / 10000;
        
        leadershipPool.balance += leadershipShare;
        communityPool.balance += communityShare;
        clubPool.balance += clubShare;
    }
    
    function distributePool(uint8 poolType) external onlyAdmin nonReentrant {
        CoreOptimized.PackedPool storage pool = _getPool(poolType);
        require(pool.balance > 0, "Pool empty");
        
        address[] memory eligibleUsers = _getEligibleUsers(poolType);
        require(eligibleUsers.length > 0, "No eligible users");
        
        // Batch processing for gas optimization
        uint96 distributionAmount = pool.balance / uint96(eligibleUsers.length);
        uint256 batchSize = eligibleUsers.length > 50 ? 50 : eligibleUsers.length;
        
        for (uint256 i = 0; i < batchSize; i++) {
            _distributeReward(eligibleUsers[i], distributionAmount, poolType + 10);
        }
        
        pool.balance = 0;
        pool.lastDistribution = uint32(block.timestamp);
        emit PoolDistributed(poolType, distributionAmount * uint96(batchSize));
    }
    
    function _getPool(uint8 poolType) private view returns (CoreOptimized.PackedPool storage) {
        if (poolType == 1) return leadershipPool;
        if (poolType == 2) return communityPool;
        if (poolType == 3) return clubPool;
        revert("Invalid pool type");
    }
    
    function _getEligibleUsers(uint8 poolType) private view returns (address[] memory) {
        // Simplified eligibility check for stack depth optimization
        address[] memory eligible = new address[](10); // Fixed size for optimization
        uint256 count = 0;
        
        // Sample implementation - would be expanded based on pool requirements
        for (uint32 i = 1; i <= totalUsers && count < 10; i++) {
            address user = userIds[i];
            if (users[user].packageLevel >= poolType && users[user].directReferrals >= poolType) {
                eligible[count] = user;
                count++;
            }
        }
        
        // Resize array to actual count
        address[] memory result = new address[](count);
        for (uint256 i = 0; i < count; i++) {
            result[i] = eligible[i];
        }
        return result;
    }

    // ========== NETWORK MANAGEMENT ==========
    
    function _updateNetworkStructure(address user, address sponsor) private {
        if (sponsor == address(0)) return;
        
        // Smart tree matrix placement algorithm
        _assignMatrixPosition(user, sponsor);
        
        // Update team sizes up the network
        _updateTeamSizes(sponsor);
    }
    
    function _assignMatrixPosition(address user, address sponsor) private {
        // Iterative matrix placement algorithm
        address currentParent = sponsor;
        
        while (currentParent != address(0)) {
            if (smartTreeMatrix[currentParent][0] == address(0)) {
                smartTreeMatrix[currentParent][0] = user;
                break;
            } else if (smartTreeMatrix[currentParent][1] == address(0)) {
                smartTreeMatrix[currentParent][1] = user;
                break;
            } else {
                // Find next position in the tree
                currentParent = smartTreeMatrix[currentParent][0];
            }
        }
        
        emit NetworkPositionAssigned(user, totalUsers);
    }
    
    function _updateTeamSizes(address sponsor) private {
        address current = sponsor;
        
        // Iterative team size update
        for (uint8 level = 0; level < 10 && current != address(0); level++) {
            users[current].teamSize++;
            current = users[current].referrer;
        }
    }
    
    function calculateNetworkSize(address user) external view returns (uint32) {
        return _calculateNetworkSizeIterative(user);
    }
    
    function _calculateNetworkSizeIterative(address user) private view returns (uint32) {
        if (!users[user].isRegistered()) return 0;
        
        // Use cached value if recent
        if (block.timestamp - lastNetworkUpdate[user] < 3600) { // 1 hour cache
            return networkSizeCache[user];
        }
        
        uint32 totalSize = 0;
        address[] memory queue = new address[](1000); // Fixed size for optimization
        uint256 front = 0;
        uint256 rear = 0;
        
        // Add direct referrals to queue
        address[] memory directRefs = directNetwork[user];
        for (uint256 i = 0; i < directRefs.length && rear < 1000; i++) {
            queue[rear++] = directRefs[i];
        }
        
        // BFS traversal with depth limit for performance
        while (front < rear && totalSize < 10000) { // Limit for performance
            address current = queue[front++];
            totalSize++;
            
            // Add children to queue (limited depth)
            if (rear < 950) { // Leave room for new additions
                address[] memory currentRefs = directNetwork[current];
                for (uint256 i = 0; i < currentRefs.length && rear < 1000; i++) {
                    queue[rear++] = currentRefs[i];
                }
            }
        }
        
        return totalSize;
    }

    // ========== WITHDRAWAL FUNCTIONS ==========
    
    function withdraw(uint96 amount) external nonReentrant whenNotPaused antiMEV 
      circuitBreakerCheck(amount) {
        CoreOptimized.PackedUser storage user = users[msg.sender];
        
        // Withdrawal validation
        if (!user.isRegistered()) revert Errors.UserNotRegistered(msg.sender);
        if (user.isBlacklisted()) revert Errors.UserBlacklisted(msg.sender);
        if (amount == 0 || amount > type(uint96).max) revert Errors.InvalidAmount(amount);
        if (amount > user.balance) revert Errors.InsufficientBalance(user.balance, amount);
        if (platformFeeRecipient == address(0)) revert Errors.ZeroAddress();
        
        // Minimum withdrawal threshold
        if (amount < 1e6) revert Errors.InvalidValue();
        
        uint8 withdrawalRate = calculateWithdrawalRate(msg.sender);
        
        uint96 withdrawable = (amount * withdrawalRate) / 100;
        uint96 reinvestment = amount - withdrawable;
        uint96 platformFee = (withdrawable * 500) / 10000; // 5% platform fee
        uint96 participantReceives = withdrawable - platformFee;
        
        // Update state before external calls
        user.balance -= amount;
        user.totalWithdrawn += participantReceives;
        
        // Convert 6-decimal amounts to 18-decimal USDT for transfers
        uint256 participantUSDT = uint256(participantReceives) * 10**12; // Convert to 18 decimals
        uint256 platformUSDT = uint256(platformFee) * 10**12; // Convert to 18 decimals
        
        // External transfers (in 18-decimal USDT)
        usdt.transfer(msg.sender, participantUSDT);
        usdt.transfer(platformFeeRecipient, platformUSDT);
        
        // Process reinvestment
        if (reinvestment > 0) {
            _processReinvestmentDistribution(msg.sender, reinvestment);
        }
        
        emit UserWithdrawal(msg.sender, participantReceives);
        emit PlatformFeeCollected(platformFee, msg.sender);
    }

    function calculateWithdrawalRate(address user) public view returns (uint8) {
        CoreOptimized.PackedUser memory userData = users[user];
        uint32 directs = userData.directReferrals;
        
        // Tiered rates: 70%/75%/80% based on direct referrals
        if (directs >= 20) return 80;
        if (directs >= 5) return 75;
        return 70;
    }

    function _processReinvestmentDistribution(address participant, uint96 amount) internal {
        // Split reinvestment across pools
        uint96 levelShare = amount / 2;
        uint96 chainShare = amount / 4;
        uint96 helpShare = amount - levelShare - chainShare;
        
        // Level reinvestment
        if (levelShare > 0) {
            _distributeLevelReinvestment(participant, levelShare);
        }
        
        // Chain reinvestment
        if (chainShare > 0) {
            _distributeReferrerChainIncentives(participant, chainShare);
        }
        
        // Help pool
        if (helpShare > 0) {
            communityPool.balance += helpShare;
        }
    }

    function _distributeLevelReinvestment(address participant, uint96 amount) internal {
        if (amount == 0) return;
        
        address current = users[participant].referrer;
        uint8 level = 1;
        uint8 maxLevels = 30;
        uint96 remaining = amount;
        
        while (current != address(0) && level <= maxLevels && remaining > 0) {
            CoreOptimized.PackedUser storage parentUser = users[current];
            
            if (parentUser.isRegistered() && !parentUser.isBlacklisted()) {
                // Equal distribution across levels
                uint96 levelPayout = amount / maxLevels;
                
                if (levelPayout > remaining) levelPayout = remaining;
                if (levelPayout > 0) {
                    _distributeReward(current, levelPayout, 6);
                    remaining -= levelPayout;
                }
            }
            
            current = parentUser.referrer;
            level++;
        }
        
        // Any remaining to help pool
        if (remaining > 0) {
            communityPool.balance += remaining;
        }
    }

    function _distributeReferrerChainIncentives(address participant, uint96 amount) internal {
        if (amount == 0) return;
        
        // Distribute to 30 levels
        address current = users[participant].referrer;
        uint8 level = 1;
        uint8 maxParents = 30;
        uint96 remaining = amount;
        address lastValidParent = address(0);
        
        while (current != address(0) && level <= maxParents && remaining > 0) {
            CoreOptimized.PackedUser storage parentUser = users[current];
            
            if (parentUser.isRegistered() && !parentUser.isBlacklisted()) {
                uint96 perParent = remaining / (maxParents - level + 1);
                if (perParent > 0) {
                    _distributeReward(current, perParent, 5);
                    remaining -= perParent;
                    lastValidParent = current;
                }
            }
            
            current = parentUser.referrer;
            level++;
        }
        
        // Remainder distribution
        if (remaining > 0) {
            if (lastValidParent != address(0)) {
                _distributeReward(lastValidParent, remaining, 5);
            } else {
                communityPool.balance += remaining;
            }
        }
    }

    // ========== ADMIN FUNCTIONS ==========
    
    function setPlatformFeeRecipient(address _recipient) external onlyOwner {
        require(_recipient != address(0), "Zero address");
        platformFeeRecipient = _recipient;
    }

    function addAdmin(address admin) external onlyOwner {
        require(admin != address(0), "Invalid admin");
        isAdminAddress[admin] = true;
        emit AdminAdded(admin);
    }
    
    function removeAdmin(address admin) external onlyOwner {
        isAdminAddress[admin] = false;
        emit AdminRemoved(admin);
    }
    
    function setCircuitBreaker(uint256 threshold) external onlyAdmin {
        circuitBreakerThreshold = threshold;
        circuitBreakerTriggered = false;
        emit CircuitBreakerReset();
    }
    
    function updatePackagePrices() external onlyOwner {
        _setStandardPackagePrices();
    }
    
    function emergencyPause() external onlyAdmin {
        _pause();
    }
    
    function emergencyUnpause() external onlyAdmin {
        _unpause();
    }

    // ========== VIEW FUNCTIONS ==========
    
    function getUserBasicInfo(address user) external view returns (bool, uint8, uint96) {
        CoreOptimized.PackedUser storage userData = users[user];
        return (userData.isRegistered(), userData.packageLevel, userData.balance);
    }
    
    function getUserEarnings(address user) external view returns (uint96, uint96, uint32) {
        CoreOptimized.PackedUser storage userData = users[user];
        return (userData.totalEarnings, userData.earningsCap, userData.directReferrals);
    }
    
    function getUserNetwork(address user) external view returns (address, uint32) {
        CoreOptimized.PackedUser storage userData = users[user];
        return (userData.referrer, userData.teamSize);
    }
    
    function getPoolBalance(uint8 poolType) external view returns (uint96) {
        if (poolType == 1) return leadershipPool.balance;
        if (poolType == 2) return communityPool.balance;
        if (poolType == 3) return clubPool.balance;
        return 0;
    }
    
    function getMatrixPosition(address user) external view returns (address, address) {
        return (smartTreeMatrix[user][0], smartTreeMatrix[user][1]);
    }
    
    function getContractBalance() external view returns (uint256) {
        return address(this).balance;
    }
    
    function getUSDTBalance() external view returns (uint256) {
        return usdt.balanceOf(address(this));
    }
    
    function getTotalUsers() external view returns (uint32) {
        return totalUsers;
    }
    
    function getPackagePrice(uint8 packageLevel) external view returns (uint96) {
        return packages[packageLevel].price;
    }
    
    function getUSDTDecimals() external view returns (uint8) {
        return usdtDecimals;
    }
    
    function convertToUSDT18(uint96 amount6) public pure returns (uint256) {
        return uint256(amount6) * 10**12;
    }
    
    function convertFromUSDT18(uint256 amount18) public pure returns (uint96) {
        require(amount18 % 10**12 == 0, "Invalid conversion: not divisible");
        return uint96(amount18 / 10**12);
    }
    
    function getVersion() external pure returns (string memory) {
        return "1.1.0";
    }
    
    function isAdmin(address user) external view returns (bool) {
        return isAdminAddress[user] || user == owner();
    }

    // ========== UPGRADE FUNCTIONS ==========
    
    function _authorizeUpgrade(address newImplementation) internal override onlyOwner {}

    // ========== EMERGENCY FUNCTIONS ==========
    
    function emergencyWithdraw() external onlyOwner {
        require(circuitBreakerTriggered, "Only in emergency");
        // Emergency USDT withdrawal
        uint256 usdtBalance = usdt.balanceOf(address(this));
        if (usdtBalance > 0) {
            usdt.transfer(owner(), usdtBalance);
        }
        // Emergency BNB withdrawal (if any accidentally sent)
        uint256 bnbBalance = address(this).balance;
        if (bnbBalance > 0) {
            (bool success, ) = payable(owner()).call{value: bnbBalance}("");
            require(success, "Emergency withdrawal failed");
        }
    }
    
    // Allow contract to receive BNB (in case of accidental transfers)
    receive() external payable {}
    fallback() external payable {}
}
