<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OrphiCrowdFund - Fixed Deployment</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #333;
            min-height: 100vh;
        }
        .container {
            background: white;
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        }
        h1 {
            text-align: center;
            color: #2c3e50;
            margin-bottom: 30px;
        }
        .status {
            padding: 15px;
            margin: 10px 0;
            border-radius: 8px;
            border-left: 5px solid;
        }
        .status.success { background: #d4edda; border-color: #28a745; color: #155724; }
        .status.error { background: #f8d7da; border-color: #dc3545; color: #721c24; }
        .status.warning { background: #fff3cd; border-color: #ffc107; color: #856404; }
        .status.info { background: #d1ecf1; border-color: #17a2b8; color: #0c5460; }
        
        button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            margin: 5px;
            transition: all 0.3s ease;
        }
        button:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }
        button:disabled {
            background: #6c757d;
            cursor: not-allowed;
            transform: none;
        }
        
        .address {
            font-family: monospace;
            background: #f8f9fa;
            padding: 5px 8px;
            border-radius: 4px;
            word-break: break-all;
        }
        
        .config-info {
            background: #e9ecef;
            padding: 15px;
            border-radius: 8px;
            margin: 20px 0;
        }
        
        .gas-info {
            background: #fff3cd;
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
            font-size: 14px;
        }
        
        .network-badge {
            display: inline-block;
            background: #28a745;
            color: white;
            padding: 5px 10px;
            border-radius: 15px;
            font-size: 12px;
            margin: 5px 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üöÄ OrphiCrowdFund - Secure Deployment</h1>
        
        <div class="config-info">
            <h3>üìã Deployment Configuration</h3>
            <p><strong>Target Network:</strong> <span class="network-badge">BSC Mainnet (Chain ID: 56)</span></p>
            <p><strong>Trezor Address:</strong> <span class="address">0xDf628ed21f0B27197Ad02fc29EbF4417C04c4D29</span></p>
            <p><strong>Strategy:</strong> Deploy implementation contract with initialization</p>
            <p><strong>Admin Rights:</strong> Treasury, Emergency, and Pool Manager roles assigned to Trezor</p>
        </div>

        <div id="statusContainer">
            <div class="status info">
                ‚ÑπÔ∏è Ready to deploy OrphiCrowdFund implementation contract. This will deploy and initialize the contract with all admin rights assigned to your Trezor wallet.
            </div>
        </div>

        <div style="text-align: center; margin: 20px 0;">
            <button onclick="checkConnection()">üîç Check Connection</button>
            <button id="estimateBtn" onclick="estimateGas()" disabled>‚õΩ Estimate Gas</button>
            <button id="deployBtn" onclick="deployContract()" disabled>üöÄ Deploy Contract</button>
            <button id="verifyBtn" onclick="verifyDeployment()" disabled>‚úÖ Verify Deployment</button>
        </div>

        <div id="gasInfo" class="gas-info" style="display: none;">
            <h4>‚õΩ Gas Estimation</h4>
            <p id="gasDetails"></p>
        </div>

        <div id="deploymentResult"></div>
    </div>

    <script src="libs/ethers-5.7.2.umd.min.js"></script>
    <script src="contract-data.js"></script>
    <script>
        const TREZOR_ADDRESS = '0xDf628ed21f0B27197Ad02fc29EbF4417C04c4D29';
        const NETWORK_CONFIG = {
            chainId: 56,
            name: 'BSC Mainnet',
            rpcUrl: 'https://bsc-dataseed.binance.org/',
            explorer: 'https://bscscan.com'
        };

        let provider = null;
        let signer = null;
        let deployedAddress = null;
        let gasEstimate = null;

        function updateStatus(message, type = 'info') {
            const statusContainer = document.getElementById('statusContainer');
            const statusClass = type === 'success' ? 'success' : 
                              type === 'error' ? 'error' : 
                              type === 'warning' ? 'warning' : 'info';
            
            statusContainer.innerHTML = `<div class="status ${statusClass}">${message}</div>`;
            console.log(`[${type.toUpperCase()}] ${message}`);
        }

        async function checkConnection() {
            try {
                updateStatus('üîç Checking MetaMask + Trezor connection...');
                
                if (typeof window.ethereum === 'undefined') {
                    updateStatus('‚ùå MetaMask not installed. Please install MetaMask to continue.', 'error');
                    return;
                }

                // Request account access
                const accounts = await window.ethereum.request({ 
                    method: 'eth_requestAccounts' 
                });
                
                if (!accounts || accounts.length === 0) {
                    updateStatus('‚ùå No accounts connected. Please connect your wallet.', 'error');
                    return;
                }

                const connectedAddress = accounts[0];
                updateStatus(`‚úÖ Connected wallet: ${connectedAddress}`, 'success');

                // Verify Trezor address
                if (connectedAddress.toLowerCase() !== TREZOR_ADDRESS.toLowerCase()) {
                    updateStatus(`‚ö†Ô∏è Warning: Connected wallet (${connectedAddress}) does not match target Trezor address (${TREZOR_ADDRESS})`, 'warning');
                } else {
                    updateStatus('‚úÖ Trezor wallet connected successfully!', 'success');
                }

                // Initialize provider and signer
                provider = new ethers.providers.Web3Provider(window.ethereum);
                signer = provider.getSigner();
                
                // Check network
                const network = await provider.getNetwork();
                if (network.chainId !== NETWORK_CONFIG.chainId) {
                    updateStatus(`‚ö†Ô∏è Wrong network detected (Chain ID: ${network.chainId}). Please switch to ${NETWORK_CONFIG.name} (Chain ID: ${NETWORK_CONFIG.chainId})`, 'warning');
                    
                    // Try to switch network
                    try {
                        await window.ethereum.request({
                            method: 'wallet_switchEthereumChain',
                            params: [{ chainId: `0x${NETWORK_CONFIG.chainId.toString(16)}` }],
                        });
                    } catch (switchError) {
                        console.log('Failed to switch network:', switchError);
                    }
                } else {
                    updateStatus(`‚úÖ Connected to ${NETWORK_CONFIG.name}`, 'success');
                    document.getElementById('estimateBtn').disabled = false;
                }

                // Check balance
                const balance = await provider.getBalance(connectedAddress);
                const balanceEth = ethers.utils.formatEther(balance);
                updateStatus(`üí∞ Wallet balance: ${parseFloat(balanceEth).toFixed(4)} BNB`, 'info');

                if (parseFloat(balanceEth) < 0.01) {
                    updateStatus('‚ö†Ô∏è Low balance detected. You may need more BNB for gas fees.', 'warning');
                }

            } catch (error) {
                console.error('Connection error:', error);
                updateStatus(`‚ùå Connection failed: ${error.message}`, 'error');
            }
        }

        async function estimateGas() {
            try {
                updateStatus('‚õΩ Estimating gas for contract deployment and initialization...');
                
                if (!CONTRACT_DATA) {
                    updateStatus('‚ùå Contract data not loaded', 'error');
                    return;
                }

                if (!provider || !signer) {
                    updateStatus('‚ùå Please check connection first', 'error');
                    return;
                }

                // Create contract factory
                const contractFactory = new ethers.ContractFactory(
                    CONTRACT_DATA.abi,
                    CONTRACT_DATA.bytecode,
                    signer
                );

                // Estimate gas for deployment
                const deployGas = await contractFactory.signer.estimateGas(
                    contractFactory.getDeployTransaction()
                );

                // For initialization, we'll estimate based on typical initialization costs
                const estimatedInitGas = 500000; // Typical initialization gas cost
                const totalGasEstimate = deployGas.add(estimatedInitGas);

                // Get current gas price
                const gasPrice = await provider.getGasPrice();
                const gasCost = totalGasEstimate.mul(gasPrice);
                const gasCostEth = ethers.utils.formatEther(gasCost);

                gasEstimate = deployGas; // Store deployment gas estimate

                // Display gas information
                document.getElementById('gasInfo').style.display = 'block';
                document.getElementById('gasDetails').innerHTML = `
                    <strong>Deployment Gas:</strong> ${deployGas.toString()} units<br>
                    <strong>Initialization Gas:</strong> ~${estimatedInitGas.toLocaleString()} units<br>
                    <strong>Total Estimated Gas:</strong> ${totalGasEstimate.toString()} units<br>
                    <strong>Gas Price:</strong> ${ethers.utils.formatUnits(gasPrice, 'gwei')} Gwei<br>
                    <strong>Estimated Total Cost:</strong> ${parseFloat(gasCostEth).toFixed(6)} BNB<br>
                    <em>Note: Actual cost may vary. This includes both deployment and initialization.</em>
                `;

                updateStatus(`‚úÖ Gas estimation complete. Total estimated cost: ${parseFloat(gasCostEth).toFixed(6)} BNB`, 'success');
                document.getElementById('deployBtn').disabled = false;

            } catch (error) {
                console.error('Gas estimation error:', error);
                updateStatus(`‚ùå Gas estimation failed: ${error.message}`, 'error');
                
                // If gas estimation fails, still allow deployment with higher gas limit
                updateStatus('‚ö†Ô∏è Using fallback gas settings. Deployment may still work.', 'warning');
                document.getElementById('deployBtn').disabled = false;
            }
        }

        async function deployContract() {
            try {
                updateStatus('üöÄ Starting contract deployment...');
                
                if (!CONTRACT_DATA) {
                    updateStatus('‚ùå Contract data not loaded', 'error');
                    return;
                }

                if (!provider || !signer) {
                    updateStatus('‚ùå Please check connection first', 'error');
                    return;
                }

                updateStatus('üìù Creating contract factory...');
                const contractFactory = new ethers.ContractFactory(
                    CONTRACT_DATA.abi,
                    CONTRACT_DATA.bytecode,
                    signer
                );

                // Contract parameters (BSC Mainnet)
                const USDT_TOKEN = '0x55d398326f99059fF775485246999027B3197955';
                const TREASURY_ADDRESS = TREZOR_ADDRESS; // Trezor wallet as treasury
                const EMERGENCY_ADDRESS = TREZOR_ADDRESS; // Trezor wallet as emergency
                const POOL_MANAGER_ADDRESS = TREZOR_ADDRESS; // Trezor wallet as pool manager

                // Prepare deployment options
                const deployOptions = {};
                
                if (gasEstimate) {
                    // Use estimated gas with 30% buffer (upgradeable contracts need more gas)
                    deployOptions.gasLimit = gasEstimate.mul(130).div(100);
                } else {
                    // Use a high gas limit for upgradeable contracts
                    deployOptions.gasLimit = 5000000;
                }

                // Get current gas price and add buffer
                const gasPrice = await provider.getGasPrice();
                deployOptions.gasPrice = gasPrice.mul(110).div(100); // 10% buffer

                updateStatus('‚è≥ Deploying implementation contract (please confirm on Trezor)...');
                console.log('Deployment parameters:');
                console.log('USDT Token:', USDT_TOKEN);
                console.log('Treasury:', TREASURY_ADDRESS);
                console.log('Emergency:', EMERGENCY_ADDRESS);
                console.log('Pool Manager:', POOL_MANAGER_ADDRESS);
                console.log('Deploy options:', deployOptions);
                
                // Deploy the implementation contract (without initialization)
                const deployTx = await contractFactory.deploy(deployOptions);
                
                updateStatus(`‚è≥ Implementation deployment transaction sent. Hash: ${deployTx.hash}`);
                updateStatus('‚è≥ Waiting for deployment confirmation...');
                
                // Wait for deployment
                const deployedContract = await deployTx.deployed();
                const implementationAddress = deployedContract.address;
                
                updateStatus(`‚úÖ Implementation deployed at: ${implementationAddress}`, 'success');
                updateStatus('‚è≥ Now initializing contract (please confirm on Trezor)...');

                // Initialize the contract
                const initTx = await deployedContract.initialize(
                    USDT_TOKEN,
                    TREASURY_ADDRESS,
                    EMERGENCY_ADDRESS,
                    POOL_MANAGER_ADDRESS,
                    { gasLimit: 2000000 }
                );

                updateStatus(`‚è≥ Initialization transaction sent. Hash: ${initTx.hash}`);
                await initTx.wait();

                deployedAddress = implementationAddress;

                updateStatus(`‚úÖ Contract deployed and initialized successfully!`, 'success');
                
                document.getElementById('verifyBtn').disabled = false;
                
                document.getElementById('deploymentResult').innerHTML = `
                    <div class="status success">
                        <h3>üéâ Deployment Successful!</h3>
                        <p><strong>Implementation Address:</strong> <span class="address">${deployedAddress}</span></p>
                        <p><strong>Deployment Transaction:</strong> <span class="address">${deployTx.hash}</span></p>
                        <p><strong>Initialization Transaction:</strong> <span class="address">${initTx.hash}</span></p>
                        <p><strong>Explorer:</strong> <a href="${NETWORK_CONFIG.explorer}/address/${deployedAddress}" target="_blank">View on BSCScan</a></p>
                        <p><strong>ALL ADMIN ROLES assigned to:</strong> <span class="address">${TREZOR_ADDRESS}</span></p>
                        <p><strong>USDT Token:</strong> <span class="address">${USDT_TOKEN}</span></p>
                        <div class="status warning" style="margin-top: 10px;">
                            <strong>‚ö†Ô∏è Important:</strong> This is an implementation contract. For production use, you should deploy a proxy contract for upgradeability.
                        </div>
                    </div>
                `;

            } catch (error) {
                console.error('Deployment error:', error);
                
                let errorMessage = error.message;
                if (error.code === 'UNPREDICTABLE_GAS_LIMIT') {
                    errorMessage = 'Gas estimation failed. Try with manual gas settings or check contract code.';
                } else if (error.code === 'INSUFFICIENT_FUNDS') {
                    errorMessage = 'Insufficient funds for gas. Please add more BNB to your wallet.';
                } else if (error.code === 'USER_REJECTED') {
                    errorMessage = 'Transaction rejected by user.';
                } else if (error.code === -32603) {
                    errorMessage = 'Internal JSON-RPC error. Try increasing gas limit or check network connection.';
                }
                
                updateStatus(`‚ùå Deployment failed: ${errorMessage}`, 'error');
            }
        }

        async function verifyDeployment() {
            try {
                if (!deployedAddress) {
                    updateStatus('‚ùå No deployed contract to verify', 'error');
                    return;
                }

                updateStatus('üîç Verifying contract ownership...');
                
                const contract = new ethers.Contract(deployedAddress, CONTRACT_DATA.abi, provider);
                
                // Check if contract has owner function
                try {
                    const owner = await contract.owner();
                    updateStatus(`‚úÖ Contract owner: ${owner}`, 'success');
                    
                    if (owner.toLowerCase() === TREZOR_ADDRESS.toLowerCase()) {
                        updateStatus('‚úÖ Ownership verification passed! Trezor wallet has full control.', 'success');
                    } else {
                        updateStatus(`‚ùå Ownership verification failed: Expected ${TREZOR_ADDRESS}, got ${owner}`, 'error');
                    }
                } catch (ownerError) {
                    updateStatus('‚ÑπÔ∏è Contract does not have owner() function, checking admin roles...', 'info');
                    
                    // If no owner function, check admin roles
                    try {
                        const adminRole = await contract.DEFAULT_ADMIN_ROLE();
                        const hasAdminRole = await contract.hasRole(adminRole, TREZOR_ADDRESS);
                        
                        if (hasAdminRole) {
                            updateStatus('‚úÖ Admin role verification passed! Trezor wallet has admin rights.', 'success');
                        } else {
                            updateStatus(`‚ùå Admin role verification failed: Trezor address does not have admin role`, 'error');
                        }
                    } catch (roleError) {
                        updateStatus('‚ùå Unable to verify admin roles: ' + roleError.message, 'error');
                    }
                }

            } catch (error) {
                console.error('Verification error:', error);
                updateStatus(`‚ùå Verification failed: ${error.message}`, 'error');
            }
        }

        // Initialize when page loads
        window.addEventListener('load', () => {
            if (!CONTRACT_DATA) {
                updateStatus('‚ùå Contract data not loaded. Please check contract-data.js file.', 'error');
            } else {
                updateStatus('‚úÖ Contract data loaded successfully.', 'success');
            }
        });
    </script>
</body>
</html>
