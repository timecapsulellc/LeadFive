# Enhanced API Endpoints Documentation

## Overview

This documentation covers the comprehensive set of enhanced view functions designed to support advanced UI/UX requirements for the Orphi CrowdFund platform. These endpoints provide rich data structures optimized for dashboard visualization, real-time monitoring, and user experience enhancement.

## Core Enhanced Endpoints

### 1. getUserInfoEnhanced(address user)

**Purpose**: Returns comprehensive user information in a single call, eliminating the need for multiple contract queries.

**Return Structure**:
```solidity
struct UserInfoEnhanced {
    bool isRegistered;           // Registration status
    address sponsor;             // Direct sponsor address
    uint256 sponsorId;          // Sponsor's user ID
    uint256 teamSize;           // Total team members
    uint256 directReferrals;    // Direct referrals count
    uint256 totalEarnings;      // Lifetime earnings
    uint256 pendingWithdrawals; // Available for withdrawal
    uint256 lastActivity;       // Last activity timestamp
    uint256 registrationTime;   // Registration timestamp
    uint256 level;              // Current user level
    bool isActive;              // Activity status
    uint256[] matrixPositions;  // Matrix placement info
}
```

**Usage Example**:
```javascript
const userInfo = await contract.getUserInfoEnhanced(userAddress);
console.log(`User ${userAddress} has ${userInfo.teamSize} team members`);
console.log(`Total earnings: ${ethers.utils.formatEther(userInfo.totalEarnings)} USDT`);
```

**UI Integration Points**:
- User profile dashboards
- Earnings summaries
- Team statistics
- Activity tracking
- Registration verification

### 2. getMatrixInfoEnhanced(address user, uint256 level)

**Purpose**: Provides detailed matrix placement and team structure information for visualization.

**Return Structure**:
```solidity
struct MatrixInfoEnhanced {
    uint256 position;           // Position in matrix
    address[] upline;           // Upline addresses (path to root)
    address[] directDownline;   // Direct downline members
    uint256[] teamSizes;        // Size of each downline branch
    uint256 totalVolume;        // Volume generated by matrix
    uint256 matrixEarnings;     // Earnings from this matrix
    bool canReceiveBonus;       // Bonus eligibility
    uint256 nextPayoutSlot;     // Next available payout position
}
```

**Usage Example**:
```javascript
const matrixInfo = await contract.getMatrixInfoEnhanced(userAddress, 1);
// Visualize matrix structure
renderMatrixTree(matrixInfo.upline, matrixInfo.directDownline, matrixInfo.teamSizes);
```

**UI Integration Points**:
- Matrix visualization trees
- Team structure diagrams
- Bonus tracking
- Placement optimization tools

### 3. getSystemStatsEnhanced()

**Purpose**: Returns comprehensive system-wide statistics for administrative dashboards and public metrics.

**Return Structure**:
```solidity
struct SystemStatsEnhanced {
    uint256 totalMembers;       // Total registered users
    uint256 activeMembers;      // Active users (last 30 days)
    uint256 totalVolume;        // Platform lifetime volume
    uint256 dailyVolume;        // Last 24h volume
    uint256 totalDistributed;   // Total earnings distributed
    uint256 pendingDistributions; // Pending distribution amount
    uint256 lastDistributionTime; // Last distribution timestamp
    uint256 nextDistributionTime; // Next scheduled distribution
    uint256 averageTeamSize;    // Average team size per user
    uint256 platformFees;       // Total platform fees collected
    bool automationActive;      // Automation system status
    uint256 gasOptimizationSavings; // Gas savings from optimization
}
```

**Usage Example**:
```javascript
const stats = await contract.getSystemStatsEnhanced();
updateDashboard({
    members: stats.totalMembers,
    volume24h: ethers.utils.formatEther(stats.dailyVolume),
    nextPayout: new Date(stats.nextDistributionTime * 1000)
});
```

**UI Integration Points**:
- Admin dashboards
- Public statistics pages
- Performance monitoring
- System health indicators

### 4. getPoolBalancesEnhanced()

**Purpose**: Returns current balances and distribution readiness for all pool types.

**Return Structure**:
```solidity
struct PoolBalancesEnhanced {
    uint256 sponsorPool;        // Sponsor bonus pool balance
    uint256 levelPool;          // Level bonus pool balance
    uint256 uplinePool;         // Upline bonus pool balance
    uint256 leaderPool;         // Leadership pool balance
    uint256 ghpPool;            // Global High Performer pool balance
    uint256[] distributionThresholds; // Minimum amounts for distribution
    bool[] readyForDistribution;     // Which pools are ready
    uint256[] lastDistributionTimes; // Last distribution per pool
    uint256[] totalDistributed;      // Lifetime distributions per pool
    uint256 totalPoolBalance;        // Sum of all pools
}
```

**Usage Example**:
```javascript
const pools = await contract.getPoolBalancesEnhanced();
pools.readyForDistribution.forEach((ready, index) => {
    if (ready) {
        console.log(`Pool ${index} ready for distribution`);
        scheduleDistribution(index);
    }
});
```

**UI Integration Points**:
- Pool balance monitors
- Distribution schedulers
- Financial dashboards
- Automated alerts

## Automation & Monitoring Endpoints

### 5. getAutomationStatus()

**Purpose**: Provides detailed status of the automation system for monitoring and debugging.

**Return Structure**:
```solidity
struct AutomationStatus {
    bool isActive;              // Automation system status
    uint256 lastUpkeepTime;     // Last automation execution
    uint256 upkeepInterval;     // Configured interval
    uint256 gasUsedLast;        // Gas used in last upkeep
    uint256 failedAttempts;     // Recent failed attempts
    address keeper;             // Current keeper address
    bool emergencyPaused;       // Emergency pause status
}
```

### 6. getUpkeepReadiness()

**Purpose**: Determines if automated distributions should be triggered.

**Return Structure**:
```solidity
struct UpkeepReadiness {
    bool needsUpkeep;           // Should trigger upkeep
    string reason;              // Reason for upkeep need
    uint256 timeUntilNext;      // Seconds until next check
    uint256 estimatedGas;       // Estimated gas for upkeep
    uint256[] poolsToDistribute; // Which pools need distribution
}
```

## Advanced Visualization Endpoints

### 7. getDownlineVisualizationData(address user, uint256 depth)

**Purpose**: Specialized endpoint for rendering downline organization charts and network visualizations.

**Return Structure**:
```solidity
struct DownlineVisualizationData {
    address rootUser;           // Root user address
    DownlineNode[] nodes;       // All nodes in the structure
    Edge[] connections;         // Connections between nodes
    uint256[] levels;           // Level of each node
    uint256[] volumes;          // Volume contribution per node
    uint256[] joinDates;        // Registration dates
    bool[] activeStatus;        // Activity status per node
}

struct DownlineNode {
    address userAddress;        // User address
    uint256 userId;            // User ID
    string displayName;        // Display name (if available)
    uint256 level;             // Depth level
    uint256 directReferrals;   // Direct referrals count
    uint256 teamSize;          // Total team size
    uint256 volume;            // Generated volume
    bool isActive;             // Current activity status
}

struct Edge {
    address from;              // Sponsor address
    address to;                // Referred user address
    uint256 weight;            // Relationship strength/volume
    uint256 establishedDate;   // When relationship was created
}
```

**Usage Example**:
```javascript
const vizData = await contract.getDownlineVisualizationData(userAddress, 5);
renderNetworkDiagram(vizData.nodes, vizData.connections, {
    maxDepth: 5,
    showVolumes: true,
    highlightActive: true
});
```

### 8. getTeamAnalytics(address user)

**Purpose**: Provides analytics data for team performance and growth tracking.

**Return Structure**:
```solidity
struct TeamAnalytics {
    uint256 totalTeamSize;      // Total team members
    uint256 activeMembers;      // Active team members
    uint256 newMembersLast30;   // New members in last 30 days
    uint256 teamVolume30d;      // Team volume last 30 days
    uint256 teamEarnings30d;    // Team earnings last 30 days
    uint256[] levelDistribution; // Members per level
    uint256[] dailyActivity;    // Activity over last 30 days
    address[] topPerformers;    // Top 10 performing team members
    uint256[] performerVolumes; // Volumes of top performers
}
```

## Frontend Integration Patterns

### Real-time Dashboard Updates

```javascript
class OrphiDashboard {
    async updateUserDashboard(userAddress) {
        const [userInfo, systemStats, pools] = await Promise.all([
            this.contract.getUserInfoEnhanced(userAddress),
            this.contract.getSystemStatsEnhanced(),
            this.contract.getPoolBalancesEnhanced()
        ]);
        
        this.renderUserStats(userInfo);
        this.renderSystemStats(systemStats);
        this.renderPoolStatus(pools);
    }
    
    async renderNetworkVisualization(userAddress, depth = 3) {
        const vizData = await this.contract.getDownlineVisualizationData(userAddress, depth);
        const analytics = await this.contract.getTeamAnalytics(userAddress);
        
        this.networkChart.render({
            nodes: vizData.nodes,
            edges: vizData.connections,
            analytics: analytics
        });
    }
}
```

### Automated Monitoring

```javascript
class AutomationMonitor {
    async checkSystemHealth() {
        const [automation, upkeep, pools] = await Promise.all([
            this.contract.getAutomationStatus(),
            this.contract.getUpkeepReadiness(),
            this.contract.getPoolBalancesEnhanced()
        ]);
        
        if (upkeep.needsUpkeep) {
            this.triggerAlert(`Upkeep needed: ${upkeep.reason}`);
        }
        
        if (!automation.isActive) {
            this.triggerAlert('Automation system is inactive');
        }
        
        return { automation, upkeep, pools };
    }
}
```

## Performance Considerations

### Batch Queries
All enhanced endpoints are designed to minimize gas costs and network calls by returning comprehensive data structures in single transactions.

### Caching Strategy
- Cache user info for 5 minutes
- Cache system stats for 1 minute  
- Cache pool balances for 30 seconds
- Real-time updates for critical changes

### Gas Optimization
- View functions only (no state changes)
- Optimized data structures
- Minimal external calls
- Efficient storage access patterns

## Error Handling

### Common Error Codes
- `USER_NOT_REGISTERED`: User address not found in system
- `INVALID_LEVEL`: Requested level exceeds maximum
- `INSUFFICIENT_DEPTH`: Depth parameter too large for visualization
- `SYSTEM_PAUSED`: Contract is paused for maintenance

### Best Practices
```javascript
try {
    const userInfo = await contract.getUserInfoEnhanced(address);
    if (!userInfo.isRegistered) {
        throw new Error('User not registered');
    }
    return userInfo;
} catch (error) {
    console.error('Failed to fetch user info:', error.message);
    return null;
}
```

## Security Considerations

- All view functions are read-only
- No state modifications possible
- Public data only (no private user information)
- Rate limiting recommended for public interfaces
- Input validation on frontend before contract calls

## Integration Checklist

- [ ] Implement error handling for all endpoints
- [ ] Add loading states for async operations
- [ ] Cache responses appropriately
- [ ] Add real-time update mechanisms
- [ ] Implement responsive design for visualizations
- [ ] Add accessibility features for charts/graphs
- [ ] Test with various user scenarios
- [ ] Monitor gas usage and optimize calls
- [ ] Implement proper security measures
- [ ] Add comprehensive logging
