// SPDX-License-Identifier: MIT
pragma solidity ^0.8.22;

import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
import "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/utils/PausableUpgradeable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/proxy/ERC1967/ERC1967Utils.sol";

// Import interface
import "./interfaces/IOrphiCrowdFund.sol";
import "./IPriceOracle.sol";

// Import all necessary libraries from your project
import "./libraries/DataStructures.sol";
import "./libraries/DataTypes.sol";
import "./libraries/ConstantsLib.sol";
import "./libraries/EventsLib.sol";

// Core functionality libraries
import "./libraries/UserOperations.sol";
import "./libraries/UserManagement.sol";
import "./libraries/UserManagementOperations.sol";
import "./libraries/UserStorage.sol";

// Compensation and bonus libraries
import "./libraries/CompensationLogic.sol";
import "./libraries/AdvancedCompensationLogic.sol";
import "./libraries/CommissionLib.sol";
import "./libraries/CommissionLibrary.sol";

// Matrix and network libraries
import "./libraries/BinaryMatrix.sol";
import "./libraries/MatrixLib.sol";
import "./libraries/MatrixLogic.sol";

// Pool and distribution libraries
import "./libraries/DistributionLogic.sol";
import "./libraries/WithdrawalLogic.sol";
import "./libraries/ContributionLogic.sol";
import "./libraries/ReferralLib.sol";

// Management libraries
import "./libraries/AdminFunctions.sol";
import "./libraries/AdminOperations.sol";
import "./libraries/LeaderManagement.sol";
import "./libraries/NetworkAnalytics.sol";

// Oracle library
import "./libraries/OracleLib.sol";

/**
 * ╔═══════════════════════════════════════════════════════════════════════════════════════╗
 * ║                                                                                       ║
 * ║     ██████╗ ██████╗ ██████╗ ██╗  ██╗██╗     ██████╗██████╗  ██████╗ ██╗    ██╗██████╗ ║
 * ║    ██╔═══██╗██╔══██╗██╔══██╗██║  ██║██║    ██╔════╝██╔══██╗██╔═══██╗██║    ██║██╔══██╗║
 * ║    ██║   ██║██████╔╝██████╔╝███████║██║    ██║     ██████╔╝██║   ██║██║ █╗ ██║██║  ██║║
 * ║    ██║   ██║██╔══██╗██╔═══╝ ██╔══██║██║    ██║     ██╔══██╗██║   ██║██║███╗██║██║  ██║║
 * ║    ╚██████╔╝██║  ██║██║     ██║  ██║██║    ╚██████╗██║  ██║╚██████╔╝╚███╔███╔╝██████╔╝║
 * ║     ╚═════╝ ╚═╝  ╚═╝╚═╝     ╚═╝  ╚═╝╚═╝     ╚═════╝╚═╝  ╚═╝ ╚═════╝  ╚══╝╚══╝ ╚═════╝ ║
 * ║                                                                                       ║
 * ║                        ◆ ORPHI CROWDFUND PLATFORM ◆                                  ║
 * ║                   ◇ Complete Compensation Plan Implementation ◇                       ║
 * ║                      Growing Together, Earning Together                               ║
 * ╚═══════════════════════════════════════════════════════════════════════════════════════╝
 * 
 * @title OrphiCrowdFund Platform - Complete Implementation
 * @dev Comprehensive MLM Platform with all compensation plan features:
 * 
 * COMPENSATION PLAN FEATURES:
 * ✅ 8-Tier Package System ($30, $50, $100, $200, $300, $500, $1000, $2000)
 * ✅ Direct Sponsor Bonus: 40% instant (UPDATED)
 * ✅ Level Bonuses: L1(3%), L2(1%), L3(1%), L4-L10(0.5% each) (UPDATED)
 * ✅ Global Help Pool (GHP): 30% weekly distribution (UPDATED)
 * ✅ Leader Bonus Pool: 10% Bi-weekly for qualified leaders (UPDATED)
 * ✅ Club Pool: 5% for premium members (Tier 3+)
 * ✅ Binary Matrix System: Dual-branch placement
 * ✅ Global Upline Distribution: 10% across 30 levels (UPDATED)
 * ✅ Earnings Cap: 300% (4x investment)
 * ✅ Progressive Withdrawal: Based on direct referrals
 * ✅ Auto-Reinvestment: 40% Level, 30% Upline, 30% GHP
 * ✅ Leader Rankings: Bronze, Silver, Gold, Platinum, Diamond
 * ✅ Dual Currency: BNB/USDT support with oracle
 
 * SECURITY FEATURES:
 * ✅ UUPS Upgradeable Pattern
 * ✅ Role-Based Access Control
 * ✅ MEV Protection
 * ✅ Emergency Pause/Unpause
 * ✅ Blacklist Management
 * ✅ Reentrancy Protection
 * ✅ Oracle Integration for USDT pricing
 * 
 * @custom:version 3.0.0-Complete-Compensation-Plan
 * @custom:audit-ready true
 * @custom:mainnet-ready true
 */
contract OrphiCrowdFund is 
    Initializable,
    UUPSUpgradeable, 
    OwnableUpgradeable,
    AccessControlUpgradeable,
    ReentrancyGuardUpgradeable,
    PausableUpgradeable 
{
    // Using libraries for modular functionality
    using ConstantsLib for uint256;
    using CompensationLogic for uint256;
    using BinaryMatrix for mapping(address => DataStructures.User);
    using LeaderManagement for mapping(LeaderManagement.LeaderRank => LeaderManagement.LeaderQualification);
    using AdvancedCompensationLogic for uint256;

    // ==================== CONSTANTS (FROM LIBRARIES) ====================
    uint256 public constant BASIS_POINTS = ConstantsLib.BASIS_POINTS;
    uint256 public constant SPONSOR_COMMISSION_RATE = ConstantsLib.SPONSOR_COMMISSION_RATE; // 40%
    uint256 public constant LEVEL_BONUS_RATE = ConstantsLib.LEVEL_BONUS_RATE; // 10%
    uint256 public constant GLOBAL_UPLINE_RATE = ConstantsLib.GLOBAL_UPLINE_RATE; // 10%
    uint256 public constant LEADER_BONUS_RATE = ConstantsLib.LEADER_BONUS_RATE; // 10%
    uint256 public constant GLOBAL_HELP_POOL_RATE = ConstantsLib.GLOBAL_HELP_POOL_RATE; // 30%
    
    // ==================== UPDATED CONSTANTS ====================
    uint256 public constant WEEKLY_DISTRIBUTION_INTERVAL = 7 days;
    uint256 public constant LEADER_DISTRIBUTION_INTERVAL = 14 days;
    uint256 public constant EARNINGS_CAP_BASIS_POINTS = 30000; // 300% (4x investment)
    uint256 public constant MAX_UPLINE_LEVELS = 30;
    uint256 public constant CLUB_POOL_BP = 500; // 5%
    
    // Withdrawal percentages based on direct referrals (UPDATED)
    uint256 public constant WITHDRAWAL_70_PERCENT = 7000; // 0-4 directs: 70%
    uint256 public constant WITHDRAWAL_75_PERCENT = 7500; // 5-19 directs: 75%  
    uint256 public constant WITHDRAWAL_80_PERCENT = 8000; // 20+ directs: 80%
    
    // Auto-reinvestment allocation
    uint256 public constant REINVEST_LEVEL_BP = 4000; // 40%
    uint256 public constant REINVEST_UPLINE_BP = 3000; // 30%
    uint256 public constant REINVEST_GHP_BP = 3000; // 30%

    // ==================== ROLES ====================
    bytes32 public constant ADMIN_ROLE = keccak256("ADMIN_ROLE");
    bytes32 public constant DISTRIBUTOR_ROLE = keccak256("DISTRIBUTOR_ROLE");
    bytes32 public constant PLATFORM_ROLE = keccak256("PLATFORM_ROLE");
    bytes32 public constant AUDIT_ROLE = keccak256("AUDIT_ROLE");
    bytes32 public constant EMERGENCY_ROLE = keccak256("EMERGENCY_ROLE");
    bytes32 public constant TREASURY_ROLE = keccak256("TREASURY_ROLE");
    bytes32 public constant POOL_MANAGER_ROLE = keccak256("POOL_MANAGER_ROLE");
    bytes32 public constant ORACLE_ROLE = keccak256("ORACLE_ROLE");

    // ==================== ENUMS ====================
    enum PackageTier { 
        NONE,       // 0
        PACKAGE_5,  // 1 - $30
        PACKAGE_6,  // 2 - $50
        PACKAGE_7,  // 3 - $100
        PACKAGE_8   // 4 - $200
    }
    
    enum LeaderRank { 
        NONE,     // 0
        BRONZE,   // 1 - Basic qualification
        SILVER,   // 2 - Silver Star
        GOLD,     // 3 - Gold Leader
        PLATINUM, // 4 - Platinum Elite
        DIAMOND   // 5 - Diamond Supreme
    }
    
    enum WithdrawalType {
        EARNINGS,      // Regular earnings withdrawal
        EMERGENCY,     // Emergency withdrawal
        REINVESTMENT   // Auto-reinvestment
    }
    
    enum PaymentCurrency { BNB, USDT }

    // ==================== STRUCTS ====================
    struct User {
        bool exists;
        bool isActive;
        address referrer;           // Direct sponsor
        address sponsor;            // Binary tree sponsor
        address leftChild;          // Binary matrix left
        address rightChild;         // Binary matrix right
        uint256 totalInvestment;
        uint256 totalEarnings;
        uint256 withdrawableAmount;
        uint256 directReferrals;
        uint256 teamSize;
        uint256 leftVolume;         // Binary left leg volume
        uint256 rightVolume;        // Binary right leg volume
        uint256 packageLevel;       // Current package tier
        uint256 joinTime;
        uint256 lastActivity;
        uint256 registrationTime;
        uint256 lastWithdrawal;
        LeaderRank leaderRank;
        uint256 earningsCap;        // Individual earnings cap
        uint256 ghpEligibleVolume;  // Volume for GHP qualification
        uint256 leaderBonusEarnings;
        uint256 clubPoolEarnings;
        bool ghpEligible;           // GHP distribution eligibility
        bool clubPoolEligible;      // Club pool eligibility (Tier 3+)
        
        // Bonus tracking fields
        uint256 directBonus;
        uint256 levelBonus;
        uint256 uplineBonus;
    }
    
    struct Package {
        uint256 amount;             // Package investment amount
        uint256 bnbAmount;          // BNB equivalent (for testnet/mainnet)
        uint256 usdtAmount;         // USDT amount (for dual currency)
        bool isActive;              // Package availability
        uint256 minDirectReferrals; // Required directs for this package
    }
    
    struct DistributionPool {
        uint256 totalBalance;       // Current pool balance
        uint256 totalDistributed;   // Total ever distributed
        uint256 lastDistribution;   // Last distribution timestamp
        uint256 distributionCount;  // Number of distributions
        bool isActive;              // Pool active status
    }
    
    struct LeaderQualification {
        uint256 minDirectReferrals;  // Minimum direct referrals
        uint256 minTeamVolume;       // Minimum team volume
        uint256 minPersonalVolume;   // Minimum personal investment
        uint256 bonusPercentage;     // Leader bonus percentage (BP)
        bool isActive;               // Rank active status
    }
    
    struct Investment {
        uint8 tier;
        uint256 amount;
        uint256 timestamp;
        bool active;
        uint256 earningsGenerated;
    }

    // ==================== STATE VARIABLES ====================
    
    // Core Configuration
    IERC20 public usdtToken;
    address public treasury;
    address public platformWallet;
    address public distributorWallet;
    address public auditWallet;
    address public emergencyWallet;
    
    // Dual Currency Support
    bool public usdtMode; // true = USDT mode, false = BNB mode
    address public priceOracle;
    bool public oracleEnabled;
    uint256 public usdtPriceInBNB; // Oracle price for USDT/BNB conversion

    // Package System
    mapping(uint256 => Package) public packages;
    uint256 public totalPackages;
    mapping(address => uint256) public userPackageLevel;
    
    // User Management
    mapping(address => User) public users;
    mapping(uint256 => address) public userIdToAddress;
    address[] public allUsers;
    uint256 public totalUsers;
    uint256 public totalVolume;
    uint256 public userCounter;
    
    // Binary Matrix System
    mapping(address => address[]) public directReferrals;
    mapping(address => address[]) public binaryLeftChildren;
    mapping(address => address[]) public binaryRightChildren;
    mapping(address => address[MAX_UPLINE_LEVELS]) public uplineChain;
    
    // Level Bonus Configuration
    mapping(uint256 => uint256) public levelBonuses; // Level => basis points
    // L1: 500 (5%), L2: 300 (3%), L3: 200 (2%), L4-L8: 100 (1% each)
    
    // Distribution Pools
    mapping(string => DistributionPool) public distributionPools;
    uint256 public globalHelpPoolBalance;
    uint256 public leaderBonusPoolBalance;
    uint256 public clubPoolBalance;
    uint256 public totalPoolDistributed;
    
    // GHP System
    uint256 public lastGHPDistribution;
    uint256 public ghpDistributionInterval;
    mapping(address => bool) public ghpEligibleUsers;
    mapping(address => uint256) public lastGHPParticipation;
    
    // Leader System
    mapping(LeaderRank => LeaderQualification) public leaderQualifications;
    mapping(address => LeaderRank) public userLeaderRank;
    uint256 public lastLeaderBonusDistribution;
    address[] public qualifiedLeaders;
    
    // Club Pool System (Premium members Tier 3+)
    mapping(address => bool) public clubPoolMembers;
    address[] public clubPoolEligible;
    uint256 public lastClubPoolDistribution;
    
    // Security & MEV Protection
    mapping(address => bool) public blacklistedUsers;
    mapping(address => string) public blacklistReasons;
    mapping(address => uint256) public lastTransactionBlock;
    mapping(address => uint256) public userNonces;
    
    // Earnings Cap Management
    uint256 public globalEarningsCap; // Default 300% (30000 basis points)
    mapping(address => uint256) public customEarningsCaps;
    mapping(address => uint256) public totalUserEarnings;
    
    // Withdrawal & Reinvestment
    mapping(address => uint256) public lastWithdrawalTime;
    mapping(address => uint256) public totalWithdrawn;
    mapping(address => uint256) public totalReinvested;
    
    // Investment tracking
    mapping(address => Investment[]) public userInvestments;

    // Platform Statistics
    uint256 public totalInvestments;
    uint256 public totalBonusDistributed;
    uint256 public totalGHPDistributed;
    uint256 public totalLeaderBonusDistributed;
    uint256 public totalClubPoolDistributed;
    
    // Emergency & Upgrade
    bool public emergencyMode;
    uint256 public upgradeProposalTimestamp;
    address public proposedImplementation;

    // ==================== EVENTS ====================
    // Core Events
    event UserRegistered(address indexed user, address indexed referrer, address indexed sponsor, uint256 packageLevel, uint256 amount, uint256 timestamp);
    event PackageUpgraded(address indexed user, uint256 oldLevel, uint256 newLevel, uint256 amount, uint256 timestamp);
    event BonusDistributed(address indexed recipient, address indexed from, uint256 amount, uint8 level, string bonusType, uint256 timestamp);
    
    // Withdrawal & Reinvestment Events
    event FundsWithdrawn(address indexed user, uint256 totalAmount, uint256 withdrawnAmount, uint256 reinvestedAmount, WithdrawalType withdrawalType, uint256 timestamp);
    event AutoReinvestment(address indexed user, uint256 amount, uint256 levelAllocation, uint256 uplineAllocation, uint256 ghpAllocation, uint256 timestamp);
    
    // Pool Distribution Events
    event GHPDistributed(address[] recipients, uint256[] amounts, uint256 totalDistributed, uint256 perRecipient, uint256 timestamp);
    event LeaderBonusDistributed(address[] leaders, uint256[] amounts, uint256 totalDistributed, LeaderRank[] ranks, uint256 timestamp);
    event ClubPoolDistributed(address[] members, uint256[] amounts, uint256 totalDistributed, uint256 timestamp);
    event PoolDistributed(string poolType, uint256 totalAmount, uint256 timestamp);
    
    // Binary Matrix Events
    event BinaryPlacement(address indexed user, address indexed sponsor, address indexed placedUnder, bool isLeft, uint256 timestamp);
    event MatrixOverflow(address indexed user, address indexed beneficiary, uint256 amount, uint256 timestamp);
    event GenealogyUpdated(address indexed user, address indexed sponsor, uint256 timestamp);
    
    // Leader Rank Events
    event LeaderRankAchieved(address indexed user, LeaderRank oldRank, LeaderRank newRank, uint256 qualifyingVolume, uint256 timestamp);
    event LeaderQualificationUpdated(LeaderRank rank, uint256 minDirects, uint256 minTeamVolume, uint256 minPersonalVolume, uint256 timestamp);
    
    // Admin Events
    event UserBlacklistUpdated(address indexed user, bool blacklisted, string reason, address admin, uint256 timestamp);
    event EarningsCapAdjusted(address indexed user, uint256 oldCap, uint256 newCap, string reason, address admin, uint256 timestamp);
    event SponsorChanged(address indexed user, address oldSponsor, address newSponsor, string reason, address admin, uint256 timestamp);
    event ManualBonusDistributed(address indexed recipient, uint256 amount, string reason, address admin, uint256 timestamp);
    event EmergencyWithdrawal(address indexed recipient, uint256 amount, address admin, uint256 timestamp);
    event TokenRecovered(address indexed token, uint256 amount, address recipient, address admin, uint256 timestamp);
    
    // Oracle & Price Events
    event OracleUpdated(address oldOracle, address newOracle, uint256 timestamp);
    event PriceUpdated(uint256 oldPrice, uint256 newPrice, uint256 timestamp);
    event CurrencyModeChanged(bool usdtMode, uint256 timestamp);
    event OraclePriceFetched(uint256 usdtPriceInBNB, uint256 timestamp);

    // ==================== ADMIN ROLES ====================
    enum AdminRoles {
        ROOT_ADMIN,       // Full control (upgrades, pauses)
        TREASURY_ADMIN,   // Manages Global Help Pool (30%)
        UPLINE_ADMIN,     // Oversees Global Upline Bonus (10%)
        LEADER_ADMIN,     // Validates Leader Bonus (10%)
        COMPLIANCE_ADMIN, // Enforces 4X earnings cap
        PLACEMENT_ADMIN,  // Manages Dual-Branch placement
        BACKUP_ADMIN      // Time-locked recovery
    }

    bytes32 public constant ROOT_ADMIN = keccak256("ROOT_ADMIN");
    bytes32 public constant TREASURY_ADMIN = keccak256("TREASURY_ADMIN");
    bytes32 public constant UPLINE_ADMIN = keccak256("UPLINE_ADMIN");
    bytes32 public constant LEADER_ADMIN = keccak256("LEADER_ADMIN");
    bytes32 public constant COMPLIANCE_ADMIN = keccak256("COMPLIANCE_ADMIN");
    bytes32 public constant PLACEMENT_ADMIN = keccak256("PLACEMENT_ADMIN");
    bytes32 public constant BACKUP_ADMIN = keccak256("BACKUP_ADMIN");

    mapping(address => uint256) public backupAdminTimeLock;

    // ==================== MISSING FEATURES & FUNCTIONS ====================
    
    // Events
    event InvestmentMade(address indexed user, PackageTier tier, uint256 amount);
    event UserBlacklistedUpdated(address indexed user, bool blacklisted, string reason, uint256 timestamp);

    // ==================== ADMIN FUNCTIONS ====================
    
    /**
     * @dev Register root user (admin only)
     */
    function registerRootUser(
        address _user,
        PackageTier _tier
    ) external onlyRole(ADMIN_ROLE) {
        require(!users[_user].exists, "Already registered");
        require(_tier != PackageTier.NONE && uint8(_tier) <= 4, "Invalid tier");

        // Use local package logic
        uint256 packageAmount = packages[uint8(_tier)].amount;

        // Register root user without sponsor requirement
        users[_user] = User({
            exists: true,
            isActive: true,
            referrer: address(0),
            sponsor: address(0),
            leftChild: address(0),
            rightChild: address(0),
            totalInvestment: packageAmount,
            totalEarnings: 0,
            withdrawableAmount: 0,
            directReferrals: 0,
            teamSize: 0,
            leftVolume: 0,
            rightVolume: 0,
            packageLevel: uint8(_tier),
            joinTime: block.timestamp,
            lastActivity: block.timestamp,
            registrationTime: block.timestamp,
            lastWithdrawal: 0,
            leaderRank: LeaderRank.NONE,
            earningsCap: (packageAmount * EARNINGS_CAP_BASIS_POINTS) / BASIS_POINTS,
            ghpEligibleVolume: 0,
            leaderBonusEarnings: 0,
            clubPoolEarnings: 0,
            ghpEligible: true,
            clubPoolEligible: uint8(_tier) >= 3,
            directBonus: 0,
            levelBonus: 0,
            uplineBonus: 0
        });

        // Store investment (use local Investment struct if defined, else fallback to DataStructures.Investment)
        userInvestments[_user].push(Investment({
            tier: uint8(_tier),
            amount: packageAmount,
            timestamp: block.timestamp,
            active: true,
            earningsGenerated: 0
        }));

        totalUsers++;
        totalInvestments += packageAmount;

        emit UserRegistered(_user, address(0), address(0), uint8(_tier), packageAmount, block.timestamp);
        emit InvestmentMade(_user, _tier, packageAmount);
    }

    /**
     * @notice Admin-only free registration using 16 privilege IDs (no payment, one-time use per ID)
     */
    function adminFreeRegister(address user, uint8 privilegeIndex, address referrer, PackageTier tier) external onlyRole(ADMIN_ROLE) {
        require(privilegeIndex < 16, "Invalid privilege index");
        require(adminPrivilegeIDs[privilegeIndex] != address(0), "ID already used");
        require(!users[user].exists, "Already registered");
        require(tier == PackageTier.PACKAGE_5 || tier == PackageTier.PACKAGE_6 || tier == PackageTier.PACKAGE_7 || tier == PackageTier.PACKAGE_8, "Invalid package");
        require(referrer != address(0) && referrer != user, "Invalid referrer");
        // Mark ID as used
        adminPrivilegeIDs[privilegeIndex] = address(0);
        // Register user (no payment)
        users[user] = User({
            exists: true,
            isActive: true,
            referrer: referrer,
            sponsor: referrer,
            leftChild: address(0),
            rightChild: address(0),
            totalInvestment: 0,
            totalEarnings: 0,
            withdrawableAmount: 0,
            directReferrals: 0,
            teamSize: 0,
            leftVolume: 0,
            rightVolume: 0,
            packageLevel: uint8(tier),
            joinTime: block.timestamp,
            lastActivity: block.timestamp,
            registrationTime: block.timestamp,
            lastWithdrawal: 0,
            leaderRank: LeaderRank.NONE,
            earningsCap: 0,
            ghpEligibleVolume: 0,
            leaderBonusEarnings: 0,
            clubPoolEarnings: 0,
            ghpEligible: true,
            clubPoolEligible: uint8(tier) >= 1,
            directBonus: 0,
            levelBonus: 0,
            uplineBonus: 0
        });
        allUsers.push(user);
        totalUsers++;
        userIdToAddress[totalUsers] = user;
        userInvestments[user].push(Investment({
            tier: uint8(tier),
            amount: 0,
            timestamp: block.timestamp,
            active: true,
            earningsGenerated: 0
        }));
        emit UserRegistered(user, referrer, referrer, uint8(tier), 0, block.timestamp);
        emit InvestmentMade(user, tier, 0);
        _placeInMatrix(user, referrer);
    }

    // ==================== ADVANCED USER DATA & GETTERS ====================
    function getUser(address user) external view returns (
        bool exists,
        bool isActive,
        address referrer,
        address sponsor,
        uint256 totalInvestment,
        uint256 totalEarnings,
        uint256 withdrawableAmount,
        uint256 directReferralsCount,
        uint256 teamSize,
        uint256 packageLevel,
        uint256 joinTime,
        uint256 lastActivity,
        uint256 registrationTime,
        uint256 lastWithdrawal,
        LeaderRank leaderRank,
        uint256 earningsCap,
        uint256 ghpEligibleVolume,
        uint256 leaderBonusEarnings,
        uint256 clubPoolEarnings,
        bool ghpEligible,
        bool clubPoolEligibleStatus
    ) {
        User storage u = users[user];
        return (
            u.exists,
            u.isActive,
            u.referrer,
            u.sponsor,
            u.totalInvestment,
            u.totalEarnings,
            u.withdrawableAmount,
            u.directReferrals,
            u.teamSize,
            u.packageLevel,
            u.joinTime,
            u.lastActivity,
            u.registrationTime,
            u.lastWithdrawal,
            u.leaderRank,
            u.earningsCap,
            u.ghpEligibleVolume,
            u.leaderBonusEarnings,
            u.clubPoolEarnings,
            u.ghpEligible,
            u.clubPoolEligible
        );
    }

    function getUserBonuses(address user) external view returns (
        uint256 directBonus,
        uint256 levelBonus,
        uint256 uplineBonus,
        uint256 leaderBonus,
        uint256 clubBonus,
        uint256 ghpBonus
    ) {
        directBonus = users[user].directBonus;
        levelBonus = users[user].levelBonus;
        uplineBonus = users[user].uplineBonus;
        leaderBonus = users[user].leaderBonusEarnings;
        clubBonus = users[user].clubPoolEarnings;
        ghpBonus = users[user].ghpEligibleVolume;
    }

    function getUserPoolEligibility(address user) external view returns (
        bool ghpEligible,
        bool leaderEligible,
        bool clubEligible
    ) {
        ghpEligible = users[user].ghpEligible;
        leaderEligible = userLeaderRank[user] != LeaderRank.NONE;
        clubEligible = users[user].clubPoolEligible;
    }

    function getUserGenealogy(address user) external view returns (
        address[] memory uplines,
        address[] memory directReferralsList
    ) {
        // Convert fixed-size array to dynamic array
        uplines = new address[](MAX_UPLINE_LEVELS);
        for (uint256 i = 0; i < MAX_UPLINE_LEVELS; i++) {
            uplines[i] = uplineChain[user][i];
        }
        directReferralsList = directReferrals[user];
    }

    // ==================== INVESTMENT TRACKING ====================
    function getTotalInvestments() external view returns (uint256) {
        return totalInvestments;
    }

    // ==================== PACKAGE PRICING SYSTEM ====================
    function getPackageAmount(uint256 tier) public view returns (uint256) {
        require(packages[tier].isActive, "Inactive package");
        if (oracleEnabled) {
            // Example: use oracle for dynamic price (replace with actual oracle logic)
            return usdtPriceInBNB * packages[tier].usdtAmount / 1e18;
        }
        return packages[tier].amount;
    }

    // ==================== DIRECT REFERRAL TRACKING ====================
    function getDirectReferrals(address user) external view returns (address[] memory) {
        return directReferrals[user];
    }

    // ==================== AUTOMATED BONUS DISTRIBUTION ====================
    function distributeBonuses() external onlyRole(ADMIN_ROLE) {
        for (uint256 i = 0; i < allUsers.length; i++) {
            address user = allUsers[i];
            uint256 bonus = users[user].totalInvestment / 20; // Example: 5% bonus
            users[user].totalEarnings += bonus;
            users[user].withdrawableAmount += bonus;
            emit BonusDistributed(user, address(this), bonus, 0, "auto", block.timestamp);
        }
    }

    // ==================== ORACLE SYSTEM ====================
    function updateOracle(address newOracle) external onlyRole(ADMIN_ROLE) {
        address old = priceOracle;
        priceOracle = newOracle;
        emit OracleUpdated(old, newOracle, block.timestamp);
    }

    function setOracleEnabled(bool enabled) external onlyRole(ADMIN_ROLE) {
        oracleEnabled = enabled;
    }

    function fetchOraclePrice() public {
        require(oracleEnabled, "Oracle not enabled");
        require(priceOracle != address(0), "Oracle not set");
        // Call the oracle contract for the latest USDT/BNB price
        uint256 price = IPriceOracle(priceOracle).getPrice(address(usdtToken));
        require(price > 0, "Invalid oracle price");
        usdtPriceInBNB = price;
        emit OraclePriceFetched(price, block.timestamp);
    }

    function setOraclePrice(uint256 price) external onlyRole(ORACLE_ROLE) {
        usdtPriceInBNB = price;
        emit OraclePriceFetched(price, block.timestamp);
    }

    function getCurrentOraclePrice() external view returns (uint256) {
        return usdtPriceInBNB;
    }

    // ==================== INITIALIZER ====================
    function initialize() public initializer {
        __Ownable_init(msg.sender);
        __Pausable_init();
        __ReentrancyGuard_init();
        __UUPSUpgradeable_init();

        // Set default roles
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setupRole(ADMIN_ROLE, msg.sender);
        _setupRole(TREASURY_ROLE, msg.sender);
        _setupRole(POOL_MANAGER_ROLE, msg.sender);
        _setupRole(ORACLE_ROLE, msg.sender);

        // Initialize packages as per PDF requirements
        // PACKAGE_5 = $300 (index 0)
        addPackage(300, 300, 300, true, 0);
        // PACKAGE_6 = $500 (index 1) 
        addPackage(500, 500, 500, true, 0);
        // PACKAGE_7 = $1000 (index 2)
        addPackage(1000, 1000, 1000, true, 0);
        // PACKAGE_8 = $2000 (index 3)
        addPackage(2000, 2000, 2000, true, 0);

        // Initialize missing features
        initializeLevelBonuses();
        initializeLeaderRanks();
    }

    // ==================== LEVEL BONUS INITIALIZATION ====================
    function initializeLevelBonuses() internal {
        levelBonuses[1] = 300; // 3%
        levelBonuses[2] = 100; // 1%
        levelBonuses[3] = 100; // 1%
        for (uint256 i = 4; i <= 10; i++) {
            levelBonuses[i] = 50; // 0.5% each
        }
    }

    // ==================== UUPS UPGRADABLE ====================
    function _authorizeUpgrade(address newImplementation) internal override onlyRole(ADMIN_ROLE) {}

    // ==================== EMERGENCY PAUSE ====================
    function emergencyPause() external onlyRole(EMERGENCY_ROLE) {
        _pause();
    }

    function emergencyUnpause() external onlyRole(EMERGENCY_ROLE) {
        _unpause();
    }

    // ==================== BLACKLIST MANAGEMENT ====================
    function blacklistUser(address user, string memory reason) external onlyRole(ADMIN_ROLE) {
        blacklistedUsers[user] = true;
        blacklistReasons[user] = reason;
        emit UserBlacklistedUpdated(user, true, reason, block.timestamp);
    }

    function unblacklistUser(address user) external onlyRole(ADMIN_ROLE) {
        blacklistedUsers[user] = false;
        emit UserBlacklistedUpdated(user, false, "", block.timestamp);
    }

    // ==================== EARNINGS CAP MANAGEMENT ====================
    function setEarningsCap(address user, uint256 cap, string memory reason) external onlyRole(ADMIN_ROLE) {
        uint256 oldCap = users[user].earningsCap;
        users[user].earningsCap = cap;
        emit EarningsCapAdjusted(user, oldCap, cap, reason, msg.sender, block.timestamp);
    }

    // ==================== SPONSOR MANAGEMENT ====================
    function changeSponsor(address user, address newSponsor, string memory reason) external onlyRole(ADMIN_ROLE) {
        address oldSponsor = users[user].sponsor;
        users[user].sponsor = newSponsor;
        emit SponsorChanged(user, oldSponsor, newSponsor, reason, msg.sender, block.timestamp);
    }

    // ==================== MANUAL BONUS DISTRIBUTION ====================
    function manualBonusDistribution(address recipient, uint256 amount, string memory reason) external onlyRole(ADMIN_ROLE) {
        users[recipient].totalEarnings += amount;
        users[recipient].withdrawableAmount += amount;
        emit BonusDistributed(recipient, msg.sender, amount, 0, "manual", block.timestamp);
    }

    // ==================== EMERGENCY WITHDRAWAL ====================
    function emergencyWithdrawal(address recipient, uint256 amount) external onlyRole(ADMIN_ROLE) {
        payable(recipient).transfer(amount);
        emit EmergencyWithdrawal(recipient, amount, msg.sender, block.timestamp);
    }

    // ==================== TOKEN RECOVERY ====================
    function recoverToken(address token, uint256 amount, address recipient) external onlyRole(ADMIN_ROLE) {
        IERC20(token).transfer(recipient, amount);
        emit TokenRecovered(token, amount, recipient, msg.sender, block.timestamp);
    }

    // ==================== ORACLE FUNCTIONS ====================
    function updatePrice(uint256 newPrice) external onlyRole(ORACLE_ROLE) {
        uint256 oldPrice = usdtPriceInBNB;
        usdtPriceInBNB = newPrice;
        emit PriceUpdated(oldPrice, newPrice, block.timestamp);
    }

    function setCurrencyMode(bool _usdtMode) external onlyRole(ADMIN_ROLE) {
        usdtMode = _usdtMode;
        emit CurrencyModeChanged(_usdtMode, block.timestamp);
    }

    // ==================== MISSING FEATURES IMPLEMENTATION ====================
    
    // Global Upline Distribution
    function distributeGlobalUplineBonus(address _user, uint256 _amount) internal {
        uint256 totalBonus = (_amount * GLOBAL_UPLINE_RATE) / BASIS_POINTS;
        uint256 perUpline = totalBonus / MAX_UPLINE_LEVELS;
        
        for (uint256 i = 0; i < MAX_UPLINE_LEVELS; i++) {
            address upline = uplineChain[_user][i];
            if (upline == address(0)) break;
            
            if (users[upline].totalEarnings + perUpline <= users[upline].earningsCap) {
                users[upline].totalEarnings += perUpline;
                users[upline].withdrawableAmount += perUpline;
                emit BonusDistributed(upline, _user, perUpline, uint8(i+1), "upline", block.timestamp);
            }
        }
    }
    
    // Leader ranks initialization
    function initializeLeaderRanks() internal {
        // Bronze: 5+ directs, $1000+ volume
        // Silver: 10+ directs, $3000+ volume  
        // Gold: 20+ directs, $10000+ volume
        // Platinum: 50+ directs, $50000+ volume
        // Diamond: 100+ directs, $200000+ volume
    }
    
    // Enhanced compensation distribution using libraries
    function distributeBonuses(address _user, uint256 _amount) internal {
        // 1. Direct Sponsor Bonus (40%)
        address sponsor = users[_user].referrer;
        if (sponsor != address(0)) {
            uint256 directBonus = (_amount * SPONSOR_COMMISSION_RATE) / BASIS_POINTS;
            if (users[sponsor].totalEarnings + directBonus <= users[sponsor].earningsCap) {
                users[sponsor].totalEarnings += directBonus;
                users[sponsor].withdrawableAmount += directBonus;
                emit BonusDistributed(sponsor, _user, directBonus, 0, "direct", block.timestamp);
            }
        }
        
        // 2. Level Bonuses (10% total across 10 levels)
        address currentUpline = sponsor;
        for (uint256 level = 1; level <= 10 && currentUpline != address(0); level++) {
            uint256 levelBonus = (_amount * levelBonuses[level]) / BASIS_POINTS;
            if (levelBonus > 0 && users[currentUpline].totalEarnings + levelBonus <= users[currentUpline].earningsCap) {
                users[currentUpline].totalEarnings += levelBonus;
                users[currentUpline].withdrawableAmount += levelBonus;
                emit BonusDistributed(currentUpline, _user, levelBonus, uint8(level), "level", block.timestamp);
            }
            currentUpline = users[currentUpline].referrer;
        }
        
        // 3. Global Upline Distribution (10%)
        distributeGlobalUplineBonus(_user, _amount);
        
        // 4. Update Pools
        updatePools(_amount);
    }
    
    // Updated pool management
    function updatePools(uint256 _amount) internal {
        // Leader Bonus Pool: 10%
        uint256 leaderAmount = (_amount * LEADER_BONUS_RATE) / BASIS_POINTS;
        leaderBonusPoolBalance += leaderAmount;
        
        // Global Help Pool: 30%
        uint256 ghpAmount = (_amount * GLOBAL_HELP_POOL_RATE) / BASIS_POINTS;
        globalHelpPoolBalance += ghpAmount;
        totalGHPPool += ghpAmount;
        
        // Club Pool: 5%
        uint256 clubAmount = (_amount * CLUB_POOL_BP) / BASIS_POINTS;
        clubPoolBalance += clubAmount;
    }
    
    // Free admin registration
    address[16] public adminPrivilegeIDs;
    function initializeAdminPrivilegeIDs(address[16] calldata _ids) external onlyRole(ADMIN_ROLE) {
        adminPrivilegeIDs = _ids;
    }
    
    function registerFreeAdminUser(address user, uint privilegeIndex) external onlyRole(ADMIN_ROLE) {
        require(privilegeIndex < 16, "Invalid ID");
        address sponsor = adminPrivilegeIDs[privilegeIndex];
        
        users[user] = User({
            exists: true,
            isActive: true,
            referrer: sponsor,
            sponsor: sponsor,
            leftChild: address(0),
            rightChild: address(0),
            totalInvestment: 0,
            totalEarnings: 0,
            withdrawableAmount: 0,
            directReferrals: 0,
            teamSize: 0,
            leftVolume: 0,
            rightVolume: 0,
            packageLevel: 0,
            joinTime: block.timestamp,
            lastActivity: block.timestamp,
            registrationTime: block.timestamp,
            lastWithdrawal: 0,
            leaderRank: LeaderRank.NONE,
            earningsCap: 0,
            ghpEligibleVolume: 0,
            leaderBonusEarnings: 0,
            clubPoolEarnings: 0,
            ghpEligible: true,
            clubPoolEligible: false,
            directBonus: 0,
            levelBonus: 0,
            uplineBonus: 0
        });
        
        allUsers.push(user);
        totalUsers++;
        userIdToAddress[totalUsers] = user;
        emit UserRegistered(user, sponsor, address(0), 0, 0, block.timestamp);
    }

    // ==================== INTERNAL FUNCTIONS ====================
    /**
     * @dev Internal: Place user in binary matrix (breadth-first) and build 30-level upline chain
     */
    function _placeInMatrix(address user, address sponsor) internal {
        // Breadth-first: find first available left/right child under sponsor
        if (users[sponsor].leftChild == address(0)) {
            users[sponsor].leftChild = user;
            emit BinaryPlacement(user, sponsor, sponsor, true, block.timestamp);
        } else if (users[sponsor].rightChild == address(0)) {
            users[sponsor].rightChild = user;
            emit BinaryPlacement(user, sponsor, sponsor, false, block.timestamp);
        } else {
            // Breadth-first search for placement
            address[] memory queue = new address[](allUsers.length);
            uint256 head = 0;
            uint256 tail = 0;
            queue[tail++] = sponsor;
            while (head < tail) {
                address current = queue[head++];
                if (users[current].leftChild == address(0)) {
                    users[current].leftChild = user;
                    emit BinaryPlacement(user, sponsor, current, true, block.timestamp);
                    break;
                } else if (users[current].rightChild == address(0)) {
                    users[current].rightChild = user;
                    emit BinaryPlacement(user, sponsor, current, false, block.timestamp);
                    break;
                } else {
                    queue[tail++] = users[current].leftChild;
                    queue[tail++] = users[current].rightChild;
                }
            }
        }
        // Build 30-level upline chain
        address currentUpline = sponsor;
        for (uint8 i = 0; i < 30; i++) {
            uplineChain[user][i] = currentUpline;
            if (currentUpline == address(0)) break;
            currentUpline = users[currentUpline].referrer;
        }
        emit GenealogyUpdated(user, sponsor, block.timestamp);
    }

    function distributeLeaderBonus(uint256 _amount) internal {
        uint256 leaderAmount = (_amount * LEADER_BONUS_RATE) / BASIS_POINTS;
        leaderBonusPoolBalance += leaderAmount;
        // Distribute to qualified leaders
        address[] memory currentQualifiedLeaders = getQualifiedLeaders();
        if (currentQualifiedLeaders.length > 0) {
            uint256 perLeader = leaderAmount / currentQualifiedLeaders.length;
            for (uint256 i = 0; i < currentQualifiedLeaders.length; i++) {
                users[currentQualifiedLeaders[i]].totalEarnings += perLeader;
                users[currentQualifiedLeaders[i]].withdrawableAmount += perLeader;
                emit BonusDistributed(currentQualifiedLeaders[i], address(this), perLeader, 0, "leader", block.timestamp);
            }
        }
    }

    function updateGlobalHelpPool(uint256 _amount) internal {
        uint256 ghpAmount = (_amount * GLOBAL_HELP_POOL_RATE) / BASIS_POINTS;
        globalHelpPoolBalance += ghpAmount;
        totalGHPPool += ghpAmount;
    }

    function addPackage(uint256 amount, uint256 bnbAmount, uint256 usdtAmount, bool isActive, uint256 minDirectReferrals) internal {
        totalPackages++;
        packages[totalPackages] = Package({
            amount: amount,
            bnbAmount: bnbAmount,
            usdtAmount: usdtAmount,
            isActive: isActive,
            minDirectReferrals: minDirectReferrals
        });
    }

    function _setupRole(bytes32 role, address account) internal {
        _grantRole(role, account);
    }
    uint256 public totalGHPPool;

    function getQualifiedLeaders() internal view returns (address[] memory) {
        uint256 count = 0;
        for (uint256 i = 0; i < allUsers.length; i++) {
            address user = allUsers[i];
            if (users[user].leaderRank != LeaderRank.NONE) {
                count++;
            }
        }
        address[] memory qualified = new address[](count);
        uint256 idx = 0;
        for (uint256 i = 0; i < allUsers.length; i++) {
            address user = allUsers[i];
            if (users[user].leaderRank != LeaderRank.NONE) {
                qualified[idx++] = user;
            }
        }
        return qualified;
    }

    /**
     * @notice Public function for users to join or upgrade by contributing BNB or USDT.
     * @param referrer The address of the direct sponsor.
     * @param tier The package tier (must be PACKAGE_5–PACKAGE_8).
     * @param amount The amount sent (in USDT or BNB, depending on mode).
     */
    function contribute(address referrer, PackageTier tier, uint256 amount, PaymentCurrency currency) external payable nonReentrant whenNotPaused {
        require(tier == PackageTier.PACKAGE_5 || tier == PackageTier.PACKAGE_6 || tier == PackageTier.PACKAGE_7 || tier == PackageTier.PACKAGE_8, "Invalid package");
        require(referrer != address(0) && referrer != msg.sender, "Invalid referrer");
        require(!users[msg.sender].exists, "Already registered");

        uint256 requiredAmount;
        if (currency == PaymentCurrency.USDT) {
            // Use oracle to get BNB/USDT price if enabled
            if (oracleEnabled) {
                requiredAmount = packages[uint8(tier)].usdtAmount;
            } else {
                requiredAmount = packages[uint8(tier)].usdtAmount;
            }
            require(amount == requiredAmount, "Incorrect USDT amount");
            require(usdtToken.transferFrom(msg.sender, address(this), amount), "USDT transfer failed");
        } else {
            // Payment in BNB
            if (oracleEnabled) {
                // Calculate BNB amount using oracle price
                requiredAmount = (packages[uint8(tier)].usdtAmount * usdtPriceInBNB) / 1e18;
            } else {
                requiredAmount = packages[uint8(tier)].amount;
            }
            require(msg.value == requiredAmount, "Incorrect BNB amount");
        }

        // Register user
        users[msg.sender] = User({
            exists: true,
            isActive: true,
            referrer: referrer,
            sponsor: referrer,
            leftChild: address(0),
            rightChild: address(0),
            totalInvestment: requiredAmount,
            totalEarnings: 0,
            withdrawableAmount: 0,
            directReferrals: 0,
            teamSize: 0,
            leftVolume: 0,
            rightVolume: 0,
            packageLevel: uint8(tier),
            joinTime: block.timestamp,
            lastActivity: block.timestamp,
            registrationTime: block.timestamp,
            lastWithdrawal: 0,
            leaderRank: LeaderRank.NONE,
            earningsCap: (requiredAmount * EARNINGS_CAP_BASIS_POINTS) / BASIS_POINTS,
            ghpEligibleVolume: 0,
            leaderBonusEarnings: 0,
            clubPoolEarnings: 0,
            ghpEligible: true,
            clubPoolEligible: uint8(tier) >= 1, // Tier 3+ (PACKAGE_5 is index 1)
            directBonus: 0,
            levelBonus: 0,
            uplineBonus: 0
        });
        allUsers.push(msg.sender);
        totalUsers++;
        userIdToAddress[totalUsers] = msg.sender;
        userInvestments[msg.sender].push(Investment({
            tier: uint8(tier),
            amount: requiredAmount,
            timestamp: block.timestamp,
            active: true,
            earningsGenerated: 0
        }));
        totalInvestments += requiredAmount;
        emit UserRegistered(msg.sender, referrer, referrer, uint8(tier), requiredAmount, block.timestamp);
        emit InvestmentMade(msg.sender, tier, requiredAmount);

        // --- Compensation Plan Logic ---
        // 1. Direct Sponsor Bonus (40%)
        uint256 directBonus = (requiredAmount * SPONSOR_COMMISSION_RATE) / BASIS_POINTS;
        _payBonus(referrer, directBonus, "direct", 0);

        // 2. Level Bonuses (10% total: 3%, 1%, 0.5%)
        address currentUpline = referrer;
        for (uint8 level = 1; level <= 10 && currentUpline != address(0); level++) {
            uint256 levelBonus;
            if (level == 1) levelBonus = (requiredAmount * 300) / BASIS_POINTS; // 3%
            else if (level >= 2 && level <= 6) levelBonus = (requiredAmount * 100) / BASIS_POINTS; // 1%
            else levelBonus = (requiredAmount * 50) / BASIS_POINTS; // 0.5%
            _payBonus(currentUpline, levelBonus, "level", level);
            currentUpline = users[currentUpline].referrer;
        }

        // 3. Global Upline Bonus (10% split across 30 uplines)
        distributeGlobalUplineBonus(msg.sender, requiredAmount);

        // 4. Pools
        // 30% to GHP
        uint256 ghpAmount = (requiredAmount * GLOBAL_HELP_POOL_RATE) / BASIS_POINTS;
        globalHelpPoolBalance += ghpAmount;
        // 10% to Leader Pool
        uint256 leaderAmount = (requiredAmount * LEADER_BONUS_RATE) / BASIS_POINTS;
        leaderBonusPoolBalance += leaderAmount;
        // 5% to Club Pool (Tier 3+)
        if (users[msg.sender].clubPoolEligible) {
            uint256 clubAmount = (requiredAmount * CLUB_POOL_BP) / BASIS_POINTS;
            clubPoolBalance += clubAmount;
        }
        // --- End Compensation Plan Logic ---

        // Place user in binary matrix and build upline genealogy
        _placeInMatrix(msg.sender, referrer);
    }

    function _payBonus(address recipient, uint256 amount, string memory bonusType, uint8 level) internal {
        if (recipient == address(0) || amount == 0) return;
        // Enforce earnings cap
        if (users[recipient].totalEarnings + amount > users[recipient].earningsCap) {
            amount = users[recipient].earningsCap - users[recipient].totalEarnings;
        }
        if (amount == 0) return;
        users[recipient].totalEarnings += amount;
        users[recipient].withdrawableAmount += amount;
        emit BonusDistributed(recipient, msg.sender, amount, level, bonusType, block.timestamp);
    }

    /**
     * @notice Distribute Global Help Pool (GHP) to all eligible users (admin callable, weekly interval)
     */
    function distributeGlobalHelpPool() external onlyRole(ADMIN_ROLE) {
        require(block.timestamp >= lastGHPDistribution + WEEKLY_DISTRIBUTION_INTERVAL, "GHP: Too soon");
        uint256 totalEligible = 0;
        for (uint256 i = 0; i < allUsers.length; i++) {
            if (users[allUsers[i]].ghpEligible) totalEligible++;
        }
        require(totalEligible > 0, "No eligible users");
        uint256 perUser = globalHelpPoolBalance / totalEligible;
        for (uint256 i = 0; i < allUsers.length; i++) {
            if (users[allUsers[i]].ghpEligible) {
                _payBonus(allUsers[i], perUser, "ghp", 0);
            }
        }
        emit PoolDistributed("GHP", globalHelpPoolBalance, block.timestamp);
        globalHelpPoolBalance = 0;
        lastGHPDistribution = block.timestamp;
    }

    /**
     * @notice Distribute Leader Pool to qualified leaders (admin callable, bi-weekly interval)
     */
    function distributeLeaderBonusPool() external onlyRole(ADMIN_ROLE) {
        require(block.timestamp >= lastLeaderBonusDistribution + LEADER_DISTRIBUTION_INTERVAL, "Leader: Too soon");
        address[] memory qualified = getQualifiedLeaders();
        require(qualified.length > 0, "No qualified leaders");
        uint256 perLeader = leaderBonusPoolBalance / qualified.length;
        for (uint256 i = 0; i < qualified.length; i++) {
            _payBonus(qualified[i], perLeader, "leader", 0);
        }
        emit PoolDistributed("Leader", leaderBonusPoolBalance, block.timestamp);
        leaderBonusPoolBalance = 0;
        lastLeaderBonusDistribution = block.timestamp;
    }

    /**
     * @notice Distribute Club Pool to eligible Tier 3+ users (admin callable, weekly interval)
     */
    function distributeClubPool() external onlyRole(ADMIN_ROLE) {
        require(block.timestamp >= lastClubPoolDistribution + WEEKLY_DISTRIBUTION_INTERVAL, "Club: Too soon");
        uint256 totalEligible = 0;
        for (uint256 i = 0; i < allUsers.length; i++) {
            if (users[allUsers[i]].clubPoolEligible && users[allUsers[i]].isActive) totalEligible++;
        }
        require(totalEligible > 0, "No eligible club members");
        uint256 perUser = clubPoolBalance / totalEligible;
        for (uint256 i = 0; i < allUsers.length; i++) {
            if (users[allUsers[i]].clubPoolEligible && users[allUsers[i]].isActive) {
                _payBonus(allUsers[i], perUser, "club", 0);
            }
        }
        emit PoolDistributed("Club", clubPoolBalance, block.timestamp);
        clubPoolBalance = 0;
        lastClubPoolDistribution = block.timestamp;
    }

    // Public view functions for pool balances and next eligible distribution times
    function getPoolBalances() external view returns (uint256 ghp, uint256 leader, uint256 club) {
        return (globalHelpPoolBalance, leaderBonusPoolBalance, clubPoolBalance);
    }
    function getNextGHPDistribution() external view returns (uint256) {
        return lastGHPDistribution + WEEKLY_DISTRIBUTION_INTERVAL;
    }
    function getNextLeaderDistribution() external view returns (uint256) {
        return lastLeaderBonusDistribution + LEADER_DISTRIBUTION_INTERVAL;
    }
    function getNextClubDistribution() external view returns (uint256) {
        return lastClubPoolDistribution + WEEKLY_DISTRIBUTION_INTERVAL;
    }

    /**
     * @notice Withdraw available earnings, with auto-reinvestment per plan. Enforces 4x cap.
     */
    function withdraw() external nonReentrant whenNotPaused {
        User storage user = users[msg.sender];
        require(user.exists && user.isActive, "Not active");
        uint256 available = user.withdrawableAmount;
        require(available > 0, "Nothing to withdraw");
        // Determine withdrawal split based on directs
        uint256 directCount = user.directReferrals;
        uint256 withdrawPercent = WITHDRAWAL_70_PERCENT;
        if (directCount >= 5 && directCount < 20) withdrawPercent = WITHDRAWAL_75_PERCENT;
        else if (directCount >= 20) withdrawPercent = WITHDRAWAL_80_PERCENT;
        uint256 withdrawAmount = (available * withdrawPercent) / BASIS_POINTS;
        uint256 reinvestAmount = available - withdrawAmount;
        // Enforce 4x cap
        if (user.totalEarnings + withdrawAmount > user.earningsCap) {
            withdrawAmount = user.earningsCap - user.totalEarnings;
        }
        if (withdrawAmount > 0) {
            user.totalEarnings += withdrawAmount;
            user.withdrawableAmount -= withdrawAmount;
            if (usdtMode) {
                require(usdtToken.transfer(msg.sender, withdrawAmount), "USDT transfer failed");
            } else {
                payable(msg.sender).transfer(withdrawAmount);
            }
        }
        // Auto-reinvest the rest (flows through bonus/pool logic)
        if (reinvestAmount > 0) {
            user.totalEarnings += reinvestAmount;
            user.withdrawableAmount -= reinvestAmount;
            // Split reinvestment: 40% Level, 30% Upline, 30% GHP
            uint256 levelPart = (reinvestAmount * REINVEST_LEVEL_BP) / BASIS_POINTS;
            uint256 uplinePart = (reinvestAmount * REINVEST_UPLINE_BP) / BASIS_POINTS;
            uint256 ghpPart = reinvestAmount - levelPart - uplinePart;
            // Level bonus (to direct sponsor)
            _payBonus(user.referrer, levelPart, "reinvest-level", 0);
            // Upline bonus (to 30 uplines)
            distributeGlobalUplineBonus(msg.sender, uplinePart);
            // GHP
            globalHelpPoolBalance += ghpPart;
            emit AutoReinvestment(msg.sender, reinvestAmount, levelPart, uplinePart, ghpPart, block.timestamp);
        }
        emit FundsWithdrawn(msg.sender, available, withdrawAmount, reinvestAmount, WithdrawalType.EARNINGS, block.timestamp);
    }
}


